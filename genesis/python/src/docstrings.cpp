/*
    Genesis - A toolkit for working with phylogenetic data.
    Copyright (C) 2014-2016 Lucas Czech

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Contact:
    Lucas Czech <lucas.czech@h-its.org>
    Exelixis Lab, Heidelberg Institute for Theoretical Studies
    Schloss-Wolfsbrunnenweg 35, D-69118 Heidelberg, Germany
*/

/**
* @brief Documentation strings for the Python module.
 *
 * @file
 * @ingroup python
 */

#include <python/src/common.hpp>

#include <map>
#include <string>

static std::map<std::string, std::string> doc_strings_ = {
    {"static bool ::genesis::placement::JplaceReader::check_version (std::string const & version)", "Checks whether the version of the jplace format works with this parser.\n\nThis parser is intended for jplace versions 2 and 3. If while reading a different version tag is found, the reader will trigger a warning and try to continue anyway."},
    {"void ::genesis::placement::JplaceReader::from_document (utils::JsonDocument const & doc, Sample & smp) const", "Take a JsonDocument object and parse it as a Jplace document into a Sample object."},
    {"void ::genesis::placement::JplaceReader::from_file (std::string const & fn, Sample & smp) const", "Read a file and parse it as a Jplace document into a Sample object."},
    {"void ::genesis::placement::JplaceReader::from_files (std::vector< std::string > const & fns, SampleSet & set) const", "Read a list of files and parse them as a Jplace document into a SampleSet object."},
    {"void ::genesis::placement::JplaceReader::from_stream (std::istream & is, Sample & smp) const", "Read jplace data from a stream into a Sample.\n\nThis implementation is currenlty not yet fully implemented. Don't use it yet!"},
    {"void ::genesis::placement::JplaceReader::from_string (std::string const & jplace, Sample & smp) const", "Parse a string as a Jplace document into a Sample object."},
    {"void ::genesis::placement::JplaceReader::from_strings (std::vector< std::string > const & jps, SampleSet & set) const", "Parse a list of strings as a Jplace document into a SampleSet object."},
    {"InvalidNumberBehaviour ::genesis::placement::JplaceReader::invalid_number_behaviour () const", "Return the currenlty set InvalidNumberBehaviour."},
    {"JplaceReader & ::genesis::placement::JplaceReader::invalid_number_behaviour (InvalidNumberBehaviour val)", "Set the InvalidNumberBehaviour.\n\nThis setter controls the InvalidNumberBehaviour of the JplaceReader. The default value is InvalidNumberBehaviour::kIgnore.The function returns the JplaceReader object to allow for a fluent interface."},
    {"static std::string ::genesis::placement::JplaceReader::version ()", "Returns the version number that this class is written for. Currently, this is \"3\"."},

    {"void ::genesis::placement::JplaceWriter::to_document (const Sample & smp, utils::JsonDocument & doc) const", "Store the data of a Sample in a JsonDocument object."},
    {"void ::genesis::placement::JplaceWriter::to_file (const Sample & smp, const std::string filename) const", "Write the data of a Sample to a file in Jplace format.\n\nIf the file already exists, the function throws std::runtime_error. The function uses utils::file_write. See there for other exceptions that can be thrown."},
    {"void ::genesis::placement::JplaceWriter::to_string (const Sample & smp, std::string & output) const", "Store the data of a Sample in a string in Jplace format."},
    {"std::string ::genesis::placement::JplaceWriter::to_string (const Sample & smp) const", "Return the data of a Sample as a string in Jplace format."},

    {"void ::genesis::placement::PlacementTreeEdgeData::reset_edge_num (int val)", "Force to set the edge_num to a certain value.\n\nThe edge_num is usually considered to be constant for the tree. It rarely needs to be set, except for when constructing the object. Use with care."},




    {"PqueryName & ::genesis::placement::Pquery::add_name (std::string name="", double multiplicity=0.0)", "Create a new PqueryName using the provided parameters, add it to the Pquery and return it.\n\nAs this function might reallocate the memory where names are stored, all iterators and pointer to PqueryNamess are considered to be invalidated."},
    {"PqueryName & ::genesis::placement::Pquery::add_name (PqueryName const & other)", "Create a new PqueryName as a copy of the provided one, add it to the Pquery and return it.\n\nAs this function might reallocate the memory where names are stored, all iterators and pointer to PqueryNamess are considered to be invalidated."},
    {"PqueryPlacement & ::genesis::placement::Pquery::add_placement (PlacementTreeEdge & edge)", "Create a new PqueryPlacement at a given PlacementTreeEdge, add it to the Pquery and return it.\n\nThe values of the placement can then be adjusted using the returned object reference.It is important that the provided edge belongs to the same PlacementTree as the Pquery and its containing Sample do. This is up to the user and not checked.As this function might reallocate the memory where placements are stored, all iterators and pointer to PqueryPlacements are invalidated."},
    {"PqueryPlacement & ::genesis::placement::Pquery::add_placement (PqueryPlacement const & val)", "Create a new PqueryPlacement as a copy of the provided one, add it to the Pquery and return it.\n\nAs this function might reallocate the memory where placements are stored, all iterators and pointer to PqueryPlacements are considered to be invalidated."},
    {"PqueryPlacement & ::genesis::placement::Pquery::add_placement (PlacementTreeEdge & edge, PqueryPlacement const & val)", "Create a new PqueryPlacement at a given PlacementTreeEdge, add it to the Pquery and return it. The property values of the provided PqueryPlacement are copied.\n\nIt is important that the provided edge belongs to the same PlacementTree as the Pquery and its containing Sample do. This is up to the user and not checked.As this function might reallocate the memory where placements are stored, all iterators and pointer to PqueryPlacements are considered to be invalidated."},
    {"void ::genesis::placement::Pquery::clear ()", "Clear all data stored in this Pquery, i.e., clear all PqueryNames and all PqueryPlacements."},
    {"void ::genesis::placement::Pquery::clear_names ()", "Delete all PqueryNames of this Pquery."},
    {"void ::genesis::placement::Pquery::clear_placements ()", "Delete all PqueryPlacements of this Pquery."},
    {"PqueryName & ::genesis::placement::Pquery::name_at (size_t index)", "Return the PqueryName at a certain index.\n\nThe index must be smaller than name_size(), otherwise this functions throws an exception."},
    {"PqueryName const & ::genesis::placement::Pquery::name_at (size_t index) const", "Return the PqueryName at a certain index.\n\nThe index must be smaller than name_size(), otherwise this functions throws an exception."},
    {"size_t ::genesis::placement::Pquery::name_size () const", "Return the number of PqueryNames stored in this Pquery."},
    {"utils::Range< iterator_names > ::genesis::placement::Pquery::names ()", "Return a Range iterator to the PqueryNames.\n\nThis makes iterating placements via a range based for loop easy."},
    {"utils::Range< const_iterator_names > ::genesis::placement::Pquery::names () const", "Return a const Range iterator to the PqueryNames.\n\nThis makes iterating placements via a range based for loop easy."},
    {"PqueryPlacement & ::genesis::placement::Pquery::placement_at (size_t index)", "Return the PqueryPlacement at a certain index.\n\nThe index must be smaller than placement_size(), otherwise this functions throws an exception."},
    {"PqueryPlacement const & ::genesis::placement::Pquery::placement_at (size_t index) const", "Return the PqueryPlacement at a certain index.\n\nThe index must be smaller than placement_size(), otherwise this functions throws an exception."},
    {"size_t ::genesis::placement::Pquery::placement_size () const", "Return the number of PqueryPlacements stored in this Pquery."},
    {"utils::Range< iterator_placements > ::genesis::placement::Pquery::placements ()", "Return a Range iterator to the PqueryPlacements.\n\nThis makes iterating placements via a range based for loop easy."},
    {"utils::Range< const_iterator_placements > ::genesis::placement::Pquery::placements () const", "Return a const Range iterator to the PqueryPlacements.\n\nThis makes iterating placements via a range based for loop easy."},
    {"void ::genesis::placement::Pquery::remove_name_at (size_t index)", "Remove the PqueryName at a certain index position within this Pquery.\n\nAs this function moves names in the container, all iterators and pointer to PqueryNamess are considered to be invalidated."},
    {"void ::genesis::placement::Pquery::remove_placement_at (size_t index)", "Remove the PqueryPlacement at a certain index position within this Pquery.\n\nAs this function moves placements in the container, all iterators and pointer to PqueryPlacements are considered to be invalidated."},


    {"const PlacementTreeEdge & ::genesis::placement::PqueryPlacement::edge () const", "Get the PlacementTreeEdge where this PqueryPlacement is placed."},
    {"PlacementTreeEdge & ::genesis::placement::PqueryPlacement::edge ()", "Get the PlacementTreeEdge where this PqueryPlacement is placed."},
    {"int ::genesis::placement::PqueryPlacement::edge_num () const", "Get the edge_num where this PqueryPlacement is placed.\n\nThis number corresponds to the edge_num property as described in the jplace standard. It is not to be confused with the index of the PlacementTreeEdge."},
    {"void ::genesis::placement::PqueryPlacement::reset_edge (PlacementTreeEdge & edge)", "Set the PlacementTreeEdge at which this PqueryPlacement is placed.\n\nThis should be rarely needed. It is mostly intended for the Readers that populate the data. When setting this value, the user is responsible to make sure that the new value is actually a PlacementTreeEdge of the PlacementTree that belongs to the Sample where the Pquery of this PqueryPlacement is stored."},



    {"Pquery & ::genesis::placement::Sample::add_pquery ()", "Create an empty Pquery, add it to the Sample and return it.\n\nThe returned reference can then be used to add PqueryPlacements and PqueryNames to the Pquery.As this function might reallocate the memory where Pqueries are stored, all iterators and pointer to the Pqueries of this Sample are invalidated."},
    {"Pquery & ::genesis::placement::Sample::add_pquery (Pquery const & other)", "Create a Pquery as a copy of the provided one, add it to the sample and return it.\n\nAs this function might reallocate the memory where Pqueries are stored, all iterators and pointer to the Pqueries of this Sample are invalidated."},
    {"void ::genesis::placement::Sample::clear ()", "Clears all data of this object.\n\nThe Pqueries , the PlacementTree and the metadata are deleted."},
    {"void ::genesis::placement::Sample::clear_pqueries ()", "Clear all Pqueries  of this Sample.\n\nAll Pqueries are deleted. However, the PlacementTree and the metadata are left as they are. Thus this is a useful method for e.g., simulating placements: Take a copy of a given sample, clear its Pqueries, then generate new ones using the Simulator."},
    {"std::vector< Pquery > const & ::genesis::placement::Sample::pqueries () const", "Return a const ref to the Pquery container.\n\nThis makes iterating Pqueries via a range based for loop easy."},
    {"Pquery & ::genesis::placement::Sample::pquery_at (size_t index)", "Return the Pquery at a certain index."},
    {"Pquery const & ::genesis::placement::Sample::pquery_at (size_t index) const", "Return the Pquery at a certain index."},
    {"size_t ::genesis::placement::Sample::pquery_size () const", "Return the number of Pqueries  that are stored in this Sample."},
    {"void ::genesis::placement::Sample::remove_pquery_at (size_t index)", "Remove the Pquery at a certain index position within this Sample.\n\nAs this function might reallocate the memory where Pqueries are stored, all iterators and pointer to the Pqueries of this Sample are considered to be invalidated."},
    {"void ::genesis::placement::Sample::swap (Sample & other)", "Swap the contents of this Sample with the contents of another Sample."},
    {"PlacementTree & ::genesis::placement::Sample::tree ()", "Get the PlacementTree of this Sample."},
    {"PlacementTree const & ::genesis::placement::Sample::tree () const", "Get the PlacementTree of this Sample."},

    {"static void ::genesis::placement::SampleSerializer::load (const std::string & file_name, Sample & map)", "Loads a Sample from a binary file that was written by using save()."},
    {"static void ::genesis::placement::SampleSerializer::save (const Sample & map, const std::string & file_name)", "Saves the Sample to a binary file that can later be read by using load()."},

    {"void ::genesis::placement::SampleSet::add (std::string const & name, Sample const & smp)", "Add a Sample with a name to the SampleSet.\n\nThe Sample is copied."},
    {"NamedSample & ::genesis::placement::SampleSet::at (size_t index)", "Get the NamedSample at a certain index position."},
    {"const NamedSample & ::genesis::placement::SampleSet::at (size_t index) const", "Get the NamedSample at a certain index position."},
    {"void ::genesis::placement::SampleSet::clear ()", "Delete all Samples in this SampleSet."},
    {"bool ::genesis::placement::SampleSet::empty () const", "Return whether the SampleSet is empty."},
    {"void ::genesis::placement::SampleSet::remove_at (size_t index)", "Remove the Sample at a certain index position.\n\nAs this function moves Samples in the container around, all iterators and pointers to the elements of this SampleSet are considered to be invalidated."},
    {"size_t ::genesis::placement::SampleSet::size () const", "Return the size of the SampleSet, i.e., the number of Samples."},



    {"void ::genesis::placement::SimulatorTwostep::generate (size_t n)", "Generates n many Pqueries and places them in the Sample."},


    {"void ::genesis::placement::SimulatorTwostep::EdgeDistribution::set_depths_distributed_weights (const std::vector< int > & depth_weights)", "Set the weights so that they follow a given depth distribution of the edges in the PlacementTree.\n\nThe depth_weights vector provides weights for each level of depth for an edge in the tree. This means, each edge which is adjacent to a leaf node (speak: it has depth 0) will use the weight at position 0; edges which are one level deeper in the tree will get the weight at position 1, and so on.This method can conveniently be used with the output of Sample::closest_leaf_depth_histogram() called on some other Sample (or the same, for that matter). This way, it will mimic this smp in terms of the depths distribution of the placements: E.g., if the original smp (the one where the histrogram results were taken from and used as input for this method) has many placements near the leaves, so will the simulated one."},
    {"void ::genesis::placement::SimulatorTwostep::EdgeDistribution::set_random_subtree_weights ()", "Sets the weights of a randomly chosen subtree to 1.0, all others to 0.0."},
    {"void ::genesis::placement::SimulatorTwostep::EdgeDistribution::set_random_weights ()", "Set the weights randomly to 0.0 and 1.0."},
    {"void ::genesis::placement::SimulatorTwostep::EdgeDistribution::set_uniform_weights ()", "Sets the weights to a uniform distribution for all edges."},
    {"bool ::genesis::placement::SimulatorTwostep::EdgeDistribution::transfer_weights (const Sample & from_map)", "Sets the weights so that they follow the same distribution of placements per edge as a given Sample.\n\nThis method \"learns\" how the placements on the given smp are distributed by counting them and using those counts as weights. This way, the given distribution can be imitated by randomly generated placements.The method is intended to be used on a Tree that has the same topology as the one that is given with the Sample, otherwise the Edge indices will not fit. It does not need to be the same Sample or Tree  usually, an empty copy is used.\n\nsmp\n\n\nUse the counts of placements of this smp to set the weights.\n\n\nReturns true iff the smp has the same topology as the one used for simulation. If false, no weights were set."},



    {"void ::genesis::sequence::FastaReader::from_file (std::string const & fn, SequenceSet & sset) const", "Read all Sequences from a file in Fasta format into a SequenceSet."},
    {"void ::genesis::sequence::FastaReader::from_stream (std::istream & is, SequenceSet & sset) const", "Read all Sequences from a std::istream in Fasta format into a SequenceSet."},
    {"void ::genesis::sequence::FastaReader::from_string (std::string const & fs, SequenceSet & sset) const", "Read all Sequences from a std::string in Fasta format into a SequenceSet."},
    {"bool ::genesis::sequence::FastaReader::is_validating () const", "Return whether currently chars are set for validating the Sequence sites.\n\nThis functions returns true iff there are chars set for validating Sequence sites. Use validate_chars() for getting those chars."},
    {"bool ::genesis::sequence::FastaReader::parse_fasta_sequence (utils::CountingIstream & input_stream, Sequence & sequence) const", "Parse a char sequence in Fasta format.\n\nThis function takes an input stream and interprets as as a Fasta formatted sequence. It extracts the data and writes it into the given Sequence object. See the class description of FastaReader for the expected data format.The function stops after parsing one such sequence. It returns true if a sequence was extracted and false if the stream is empty. If the input is not in the correct format, an std::runtime_error exception is thrown indicating the malicious position in the input stream.More information on the format can be found at:\nhttp://en.wikipedia.org/wiki/FASTA_formathttp://blast.ncbi.nlm.nih.gov/blastcgihelp.shtmlhttp://zhanglab.ccmb.med.umich.edu/FASTA/\nSee parse_fasta_sequence_fast() for a faster (~ double the speed), but non-error-checking version of this function."},
    {"bool ::genesis::sequence::FastaReader::parse_fasta_sequence_fast (utils::CountingIstream & input_stream, Sequence & sequence) const", "Parse a Fasta sequence without checking for errors.\n\nThis is a very fast implementation that neglects input error checking. Thus, the Fasta sequence has to be well-formed in order for this function to work properly. See the class description of FastaReader for the expected data format.If the expected conditions are not met, instead of exceptions, undefined behaviour results. Most probably, it will either write rubbish into the sequence or produce a segfault or an infinite loop. So be warned and check your data first. If they are good, enjoy the speed!"},
    {"FastaReader & ::genesis::sequence::FastaReader::to_upper (bool value)", "Set whether Sequence sites are automatically turned into upper case.\n\nIf set to true (default), all sites of the read Sequences are turned into upper case letters automatically. This is demanded by the Fasta standard. The function returns the FastaReader object to allow for fluent interfaces."},
    {"bool ::genesis::sequence::FastaReader::to_upper () const", "Return whether Sequence sites are automatically turned into upper case."},
    {"utils::CharLookup & ::genesis::sequence::FastaReader::valid_char_lookup ()", "Return the internal CharLookup that is used for validating the Sequence sites.\n\nThis function is provided in case direct access to the lookup is needed. Usually, the validate_chars() function should suffice. See there for details."},
    {"FastaReader & ::genesis::sequence::FastaReader::validate_chars (std::string const & chars)", "Set the chars that are used for validating Sequence sites when reading them.\n\nWhen this function is called with a string of chars, those chars are used to validate the sites when reading them. If set to an empty string, this check is deactivated. This is also the default, meaning that no checking is done.In case that to_upper() is set to true: The validation is done after making the char upper case, so that only capital letters have to be provided for validation. In case that to_upper() is set to false: All chars that are to be considered valid have to be provided for validation.See nucleic_acid_codes...() and amino_acid_codes...() functions for presettings of chars that can be used for validation here."},
    {"std::string ::genesis::sequence::FastaReader::validate_chars () const", "Return the currently set chars used for validating Sequence sites.\n\nIf none are set, an empty string is returned. See is_validating() for checking whether chars are set for validating - this is equal to checking whether this function returns an empty string."},

    {"FastaWriter & ::genesis::sequence::FastaWriter::line_length (size_t value)", "Set the line length, which determines after how many chars (Sequence sites) lines breaks are inserted when writing the Fasta file.\n\nDefault is 80. If set to 0, no breaks are inserted. The functions returns the FastaWriter object to allow fluent interfaces."},
    {"size_t ::genesis::sequence::FastaWriter::line_length () const", "Get the current line length.\n\nSee the setter line_length() for details."},
    {"void ::genesis::sequence::FastaWriter::to_file (SequenceSet const & sset, std::string const & fn) const", "Write Sequences of a SequenceSet to a file in Fasta format."},
    {"void ::genesis::sequence::FastaWriter::to_stream (SequenceSet const & sset, std::ostream & os) const", "Write Sequences of a SequenceSet to a stream in Fasta format."},
    {"std::string ::genesis::sequence::FastaWriter::to_string (SequenceSet const & sset) const", "Return Sequences of a SequenceSet in form of a Fasta formatted string.\n\nCaveat: This might be a long string! If you simply want to examine a Sequence or SequenceSet, have a look at the print() and print_color() functions."},

    {"void ::genesis::sequence::PhylipReader::from_file (std::string const & fn, SequenceSet & sset) const", "Read all Sequences from a file in Phylip format into a SequenceSet."},
    {"void ::genesis::sequence::PhylipReader::from_stream (std::istream & is, SequenceSet & sset) const", "Read all Sequences from a std::istream in Phylip format into a SequenceSet.\n\nThis function is only allowed for Mode::kSequential and Mode::kInterleaved. Automatic mode does not work, as the stream might need to be reset, which is not possible. See mode(Mode)."},
    {"void ::genesis::sequence::PhylipReader::from_string (std::string const & fs, SequenceSet & sset) const", "Read all Sequences from a std::string in Phylip format into a SequenceSet."},
    {"bool ::genesis::sequence::PhylipReader::is_validating () const", "Return whether currently chars are set for validating the Sequence sites.\n\nThis functions returns true iff there are chars set for validating Sequence sites. Use validate_chars() for getting those chars."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::label_length (size_t value)", "Set the length of the label in front of the sequences.\n\nPhylip has the weird property that labels are written in front of sequences and do not need to have a delimiter, but instead are simply the first n characters of the string. This value determines after how many chars the label ends and the actual sequence begins.If set to a value greater than 0, exaclty this many characters are read as label. Thus, they can also contain spaces. Spaces at the beginning or end of a label are stripped. The length that is dictated by the Phylip standard is 10, but any other length can also be used.If set to 0 (default), a relaxed version of Phylip is used instead, where the sequence begin is automatically detected. Labels can then be of arbitrary lengths, as long as they do not contain white spaces. However, in this case, there has to be at least one space or tab character between the label and the sequence. After this first whitespace, the rest of the line is then treated as sequence data.The function returns the PhylipReader object to allow for fluent interfaces."},
    {"size_t ::genesis::sequence::PhylipReader::label_length () const", "Return the currently set label length.\n\nSee the setter label_length( size_t ) for details."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::mode (Mode value)", "Set the mode for reading sequences.\n\nPhylip offers two variants for storing the sequences: sequential and interleaved. As there is no option or flag in the file itself, there is no chance of knowing the variant without trying to parse it. If one fails but not the other, it is proabably the latter variant. However, there are instances where both variants are valid at the same time, but yield different sequences. So, in general detecting the correct variant is undecidable, making Phylip a non-well-defined format.In order to avoid those problems, this function explicitly sets the variant being used for parsing. By default, it is set to Mode::kSequential. Use Mode::kInterleaved for the other variant.We also offer a Mode::kAutomatic. It first tries to parse in sequential mode, and, if this fails, in interleaved mode. However, as this might involve starting from the beginning of the data, this is only possible with the from_file() and from_string() readers and does not work when using the from_stream() reader. Also, be aware that using automatic mode is slower because of implementation details induced by those limitations. Try to avoid automatic mode. If possible, try to avoid Phylip at all."},
    {"Mode ::genesis::sequence::PhylipReader::mode () const", "Return the currently set mode for parsing Phylip.See the setter mode( Mode ) for details."},
    {"std::pair< size_t, size_t > ::genesis::sequence::PhylipReader::parse_phylip_header (utils::CountingIstream & it) const", "Parse a Phylip header and return the contained sequence count and length.\n\nThis helper function expects to find a Phylip header in the form x y, which describes the number of sequences x in the Phylip data and their length y. It leaves the stream at the beginning of the next line.Currently, the function does not support Phylip options. According to the standard, those might follow after the two integers, but will lead to exceptions here."},
    {"void ::genesis::sequence::PhylipReader::parse_phylip_interleaved (utils::CountingIstream & it, SequenceSet & sset) const", "Parse a whole Phylip file using the interleaved variant (Mode::kInterleaved)."},
    {"std::string ::genesis::sequence::PhylipReader::parse_phylip_label (utils::CountingIstream & it) const", "Parse and return a Phylip label.\n\nThis helper functions either takes the first label_length chars as a label or, if label_length == 0 takes all chars until the first blank as label. It returns the trimmed label and leaves the stream at the next char after the label (and after subsequent blanks)."},
    {"std::string ::genesis::sequence::PhylipReader::parse_phylip_sequence_line (utils::CountingIstream & it) const", "Parse one sequence line.\n\nThe line (which can also start after a label) is parsed until the first '\\n' char. While parsing, the options to_upper() and validate_chars() are applied according to their settings. The stream is left at the beginning of the next line."},
    {"void ::genesis::sequence::PhylipReader::parse_phylip_sequential (utils::CountingIstream & it, SequenceSet & sset) const", "Parse a whole Phylip file using the sequential variant (Mode::kSequential)."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::to_upper (bool value)", "Set whether Sequence sites are automatically turned into upper case.\n\nIf set to true (default), all sites of the read Sequences are turned into upper case letters automatically. This is demanded by the Phylip standard.The function returns the PhylipReader object to allow for fluent interfaces."},
    {"bool ::genesis::sequence::PhylipReader::to_upper () const", "Return whether Sequence sites are automatically turned into upper case."},
    {"utils::CharLookup & ::genesis::sequence::PhylipReader::valid_char_lookup ()", "Return the internal CharLookup that is used for validating the Sequence sites.\n\nThis function is provided in case direct access to the lookup is needed. Usually, the validate_chars() function should suffice. See there for details."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::validate_chars (std::string const & chars)", "Set the chars that are used for validating Sequence sites when reading them.\n\nWhen this function is called with a string of chars, those chars are used to validate the sites when reading them. If set to an empty string, this check is deactivated. This is also the default, meaning that no checking is done.In case that to_upper() is set to true: The validation is done after making the char upper case, so that only capital letters have to be provided for validation. In case that to_upper() is set to false: All chars that are to be considered valid have to be provided for validation.See nucleic_acid_codes...() and amino_acid_codes...() functions for presettings of chars that can be used for validation here."},
    {"std::string ::genesis::sequence::PhylipReader::validate_chars () const", "Return the currently set chars used for validating Sequence sites.\n\nIf none are set, an empty string is returned. See is_validating() for checking whether chars are set for validating - this is equal to checking whether this function returns an empty string."},

    {"PhylipWriter & ::genesis::sequence::PhylipWriter::label_length (size_t value)", "Set the length of the label in front of the sequences.\n\nPhylip has the weird property that labels are written in front of sequences and do not need to have a delimiter, but instead are simply the first n characters of the string. This value determines after how many chars the label ends and the actual sequence begins.If set to 0 (default), a relaxed version of Phylip is used, where the sequence begin is automatically detected. Labels can then be of arbitrary lengths, as long as they do not contain white spaces. After the label, a space is appended.If set to a value greater than 0, the label will be cut off after that many chars. For shorter labels, the remaining number is filled with spaces. The functions returns the PhylipWriter object to allow fluent interfaces."},
    {"size_t ::genesis::sequence::PhylipWriter::label_length () const", "Return the currently set label length.\n\nSee the setter label_length( size_t ) for details."},
    {"PhylipWriter & ::genesis::sequence::PhylipWriter::line_length (size_t value)", "Set the line length, which determines after how many chars (Sequence sites) lines breaks are inserted when writing the Phylip file.\n\nDefault is 80. If set to 0, no breaks are inserted. The functions returns the PhylipWriter object to allow fluent interfaces."},
    {"size_t ::genesis::sequence::PhylipWriter::line_length () const", "Get the current line length.\n\nSee the setter line_length( size_t ) for details."},
    {"void ::genesis::sequence::PhylipWriter::to_file (SequenceSet const & sset, std::string const & fn) const", "Write Sequences of a SequenceSet to a file in Phylip format."},
    {"void ::genesis::sequence::PhylipWriter::to_stream (SequenceSet const & sset, std::ostream & os) const", "Write Sequences of a SequenceSet to a stream in Phylip format."},
    {"std::string ::genesis::sequence::PhylipWriter::to_string (SequenceSet const & sset) const", "Return Sequences of a SequenceSet in form of a Phylip formatted string.\n\nCaveat: This might be a long string! If you simply want to examine a Sequence or SequenceSet, have a look at the print() and print_color() functions."},

    {"size_t ::genesis::sequence::Sequence::length () const", "Return the length (number of sites) of this sequence."},
    {"size_t ::genesis::sequence::Sequence::size () const", "Alias for length()."},

    {"void ::genesis::sequence::SequenceSet::clear ()", "Delete all sequences from the set."},


    {"BipartitionType * ::genesis::tree::BipartitionSet::find_smallest_subtree (std::vector< NodeType * > nodes)", "Finds the smallest subtree (measured in number of nodes) that contains all given nodes.\n\nA subtree is defined by one of the two parts of a tree that are splitted by one edge. Thus, this function tries all subtrees by leaving out each edge once.If no fitting subtree exists, the function returns a nullptr."},

    {"void ::genesis::tree::ColorWriterMixin::edge_colors (std::vector< utils::Color > const & color_vector)", "Set the edge colors that shall be written to the output.\n\nIf this function is called with a vector of size > 0, the edges in the output will be colored according to the values given as a parameter. The vector then needs to contain as many elements as the tree has edges. The elements need to be indexed using the edge.index() value.If this function is called with an empty vector, the color printing is reset to not print the edge colors that might have been set before."},
    {"std::vector< utils::Color > ::genesis::tree::ColorWriterMixin::edge_colors ()", "Return the edge colors that are currently set."},
    {"void ::genesis::tree::ColorWriterMixin::enable_color (bool value)", "Set whether colors tags are written to the output."},
    {"bool ::genesis::tree::ColorWriterMixin::enable_color () const", "Returns whether colors tags are written to the output."},
    {"void ::genesis::tree::ColorWriterMixin::ignored_color (utils::Color value)", "Set a color that is used as marker for partially disabling the output of color tags.\n\nAll edges that have set a color equal to the ignored color will produce no color tag output. This is thus something like \"magic pink\", where all parts of an image are rendered transparent when originially colored in pink.By default, the ignored color is black (Color(0, 0, 0)). This way, all edges that have black color will produce no color tag."},
    {"utils::Color ::genesis::tree::ColorWriterMixin::ignored_color () const", "Return the currently set ignored color. See the setter for more information."},











    {"void ::genesis::tree::NewickBroker::assign_ranks () const", "Iterate over the tree and assign ranks (= number of immediate children) to all nodes.\n\nThis function is for example needed to check whether it is a bifurcating/binary tree, or to check how many leaves and inner nodes the tree has. Thus, it is usually called after the broker is filled with data."},
    {"NewickBrokerElement & ::genesis::tree::NewickBroker::at (std::size_t index)", "Provides index based array access to the nodes, doing a boundary check first.\n\nIn out of bounds cases, a nullptr is returned."},
    {"NewickBrokerElement & ::genesis::tree::NewickBroker::bottom ()", "Returns a reference to the bottom node of the tree stack.\n\nCalling this function on an empty() broker causes undefined behavior."},
    {"const_iterator ::genesis::tree::NewickBroker::cbegin () const", "Const version of begin()."},
    {"const_iterator ::genesis::tree::NewickBroker::cend () const", "Const version of end()."},
    {"void ::genesis::tree::NewickBroker::clear ()", "Deletes all nodes from the broker."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::crbegin ()", "Const version of rbegin()."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::crend ()", "Const version of rend()."},
    {"std::string ::genesis::tree::NewickBroker::dump () const", "Return a readable string representation of the elements of the NewickBroker."},
    {"bool ::genesis::tree::NewickBroker::empty () const", "Returns whether the stack is empty."},
    {"int ::genesis::tree::NewickBroker::leaf_count () const", "Returns the number of leaf nodes in the tree. assign_ranks() has to be called first."},
    {"int ::genesis::tree::NewickBroker::max_rank () const", "Returns the highest rank of the nodes in the tree. assign_ranks() has to be called first."},
    {"int ::genesis::tree::NewickBroker::node_count () const", "Alias for size()."},
    {"reverse_iterator ::genesis::tree::NewickBroker::rbegin ()", "Returns a reverse iterator to the nodes on the stack."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::rbegin () const", "Returns a reverse iterator to the nodes on the stack for const objects."},
    {"reverse_iterator ::genesis::tree::NewickBroker::rend ()", "Reverse version of end()."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::rend () const", "Reverse version of end() for const objects."},
    {"size_t ::genesis::tree::NewickBroker::size () const", "Returns the size of the stack, i.e. the number of nodes stored in the broker."},
    {"NewickBrokerElement & ::genesis::tree::NewickBroker::top ()", "Returns a reference to the top node of the tree stack.\n\nUsually, the top element is the root of the tree (i.e., it has depth zero). Only when called during the broker is being filled with nodes (for example, while parsing a Newick tree), the top element is not the root.Calling this function on an empty() broker causes undefined behavior."},
    {"bool ::genesis::tree::NewickBroker::validate () const", "Returns true iff the tree is valid. assign_ranks() has to be called first.\n\nA valid tree in a NewickBroker has to fullfill those criteria:\nIt's rank has to match the property is_leaf: Leaves have rank 0; a node with a higher rank cannot be a leaf.Furthermore, rank 1 is not valid, as this represents a node that is not furcating in any way.The depth (nesting level) of the nodes cannot increase more than one level between nodes, as this would imply a non-existing node with a depth in between. However, it can arbitrarily decrease, as this simply means the end of a subtree. %"},

    {"int ::genesis::tree::NewickBrokerElement::rank () const", "Returns the rank (number of immediate children) of this node.\n\nNewickBroker::assign_ranks() has to be called before using this function. Otherwise, this function will throw an std::logic_error."},

    {"void ::genesis::tree::NewickColorWriterMixin::color_tag_prefix (std::string prefix)", "Set the prefix string that is used within the Newick comment before the actual color value.\n\nBy default, this string is set to &!color=, which is for example used by FigTree to mark color in trees. This will result in a Newick comment like [&!color=#c0ffee]."},
    {"std::string ::genesis::tree::NewickColorWriterMixin::color_tag_prefix ()", "Get the currently set prefix string. See the setter for more information."},
    {"void ::genesis::tree::NewickColorWriterMixin::color_tag_suffix (std::string suffix)", "Set the suffix string that is used within the Newick comment after the actual color value.\n\nBy default, this string is empty. See the setter color_tag_prefix() for more information."},
    {"std::string ::genesis::tree::NewickColorWriterMixin::color_tag_suffix ()", "Get the currently set suffix string. See the setter for more information."},


    {"bool ::genesis::tree::NewickReader::from_file (const std::string & filename, TreeType & tree)", "Create a Tree from a file containing a Newick tree.\n\nReturns true iff successful."},
    {"bool ::genesis::tree::NewickReader::from_file (const std::string & filename, TreeSet< TreeType > & tree_set)", "Fill a TreeSet from a file containing a list of Newick trees.\n\nSee from_string() for information on the syntax of this file. The tree names are taken from the content if availabe. Unnamed trees will be prefixed by the file name.Returns true iff successful."},
    {"bool ::genesis::tree::NewickReader::from_files (const std::vector< std::string > & filenames, TreeSet< TreeType > & tree_set)", "Fill a TreeSet from a list of files containing Newick trees.\n\nReturns true iff successful."},
    {"bool ::genesis::tree::NewickReader::from_string (const std::string & tree_string, TreeType & tree)", "Create a Tree from a string containing a Newick tree.\n\nReturns true iff successful."},
    {"bool ::genesis::tree::NewickReader::from_string (const std::string & tree_string, TreeSet< TreeType > & tree_set, const std::string & default_name="")", "Fill a TreeSet from a string containing a list of Newick trees.\n\nThese trees can either be named or unnamed, using this syntax: Tree_A = (...);\n'Tree B'=(...);\n(...);\nwhere the first two lines are named trees and the third line is an unnamed tree. The trees do not have to be on distinct lines of the input, as whitespaces are completely stripped during the lexing phase. However, they are required to end with a semicolon ;.In case of unnamed trees, a default_name can be provided, which will be appended by a counter that counts up all unnamed trees. If no default name is given, the trees will simpye be named using the counter itself.Returns true iff successful."},
    {"bool ::genesis::tree::NewickReader::from_strings (const std::vector< std::string > & tree_strings, TreeSet< TreeType > & tree_set, const std::string & default_name="")", "Fill a TreeSet from a list of strings containing Newick trees.\n\nReturns true iff successful."},

    {"void ::genesis::tree::NewickWriter::to_file (const TreeType & tree, const std::string filename)", "Writes the tree to a file in Newick format.\n\nIf the file already exists, the function throws std::runtime_error. The function uses utils::file_write. See there for other exceptions that can be thrown."},
    {"void ::genesis::tree::NewickWriter::to_string (const TreeType & tree, std::string & ts)", "Gives a Newick string representation of the tree.\n\nIn case the tree was read from a Newick file, this function should produce the same representation."},
    {"std::string ::genesis::tree::NewickWriter::to_string (const TreeType & tree)", "Returns a Newick string representation of the tree.\n\nIn case the tree was read from a Newick file, this function should produce the same representation."},


    {"void ::genesis::tree::PhyloxmlWriter::to_document (const TreeType & tree, utils::XmlDocument & xml)", "Stores the information of the tree into an Phyloxml-formatted XmlDocument."},
    {"void ::genesis::tree::PhyloxmlWriter::to_file (const TreeType & tree, const std::string filename)", "Writes the tree to a file in Phyloxml format.\n\nIf the file already exists, the function throws std::runtime_error. The function uses utils::file_write. See there for other exceptions that can be thrown."},
    {"void ::genesis::tree::PhyloxmlWriter::to_string (const TreeType & tree, std::string & ts)", "Gives a Phyloxml string representation of the tree.\n\nIn case the tree was read from a Phyloxml file, this function should produce the same representation."},
    {"std::string ::genesis::tree::PhyloxmlWriter::to_string (const TreeType & tree)", "Returns a Phyloxml string representation of the tree.\n\nIn case the tree was read from a Phyloxml file, this function should produce the same representation."},

    {"void ::genesis::tree::PrinterCompact::print (std::ostream & out, TreeType const & tree, std::function< std::string(typename TreeType::NodeType const &node, typename TreeType::EdgeType const &edge)> const print_line)", "TODO this method assumes that the tree node has a name. not good."},
    {"std::string ::genesis::tree::PrinterCompact::print (TreeType const & tree)", "TODO this method assumes that the tree node has a name. not good."},



    {"void ::genesis::tree::Tree::clear ()", "Deletes all data of the tree, including all links, nodes and edges."},
    {"EdgeType & ::genesis::tree::Tree::edge_at (size_t index)", "Return the TreeEdge at a certain index."},
    {"EdgeType const & ::genesis::tree::Tree::edge_at (size_t index) const", "Return the TreeEdge at a certain index."},
    {"size_t ::genesis::tree::Tree::edge_count () const", "Return the number of TreeEdges of the Tree."},
    {"bool ::genesis::tree::Tree::empty () const", "Return whether the Tree is empty (i.e., has no nodes, edges and links)."},
    {"void ::genesis::tree::Tree::export_content (LinkContainer & links, NodeContainer & nodes, EdgeContainer & edges)", "Exports all elements of a tree.\n\nCaveat: Only the pointers to the tree elements are copied, not the elements themselves. Thus, this function is not intended for creating a deep copy. It merely is a fast way to pass pointers to tree elements."},
    {"void ::genesis::tree::Tree::import_content (LinkContainer & links, NodeContainer & nodes, EdgeContainer & edges)", "Imports all elements of a tree.\n\nThis function overwrites the topology and data of this tree with a given set of links, nodes and edges. Use with care! No checks are done concerning the validity of the passed input.Caveat: Only the pointers to the tree elements are copied, not the elements themselves. Thus, this function is not intended for creating a deep copy. It merely is a fast way to pass pointers to tree elements.Therefore, the main usage of this function is to get a tree from different Tree Reader classes for reading trees from files."},
    {"LinkType & ::genesis::tree::Tree::link_at (size_t index)", "Return the TreeLink at a certain index."},
    {"LinkType const & ::genesis::tree::Tree::link_at (size_t index) const", "Return the TreeLink at a certain index."},
    {"size_t ::genesis::tree::Tree::link_count () const", "Return the number of TreeLinks of the Tree."},
    {"NodeType & ::genesis::tree::Tree::node_at (size_t index)", "Return the TreeNode at a certain index."},
    {"NodeType const & ::genesis::tree::Tree::node_at (size_t index) const", "Return the TreeNode at a certain index."},
    {"size_t ::genesis::tree::Tree::node_count () const", "Return the number of TreeNodes of the Tree."},
    {"LinkType & ::genesis::tree::Tree::root_link ()", "Return the TreeLink at the current root of the Tree."},
    {"LinkType const & ::genesis::tree::Tree::root_link () const", "Return the TreeLink at the current root of the Tree."},
    {"NodeType & ::genesis::tree::Tree::root_node ()", "Return the TreeNode at the current root of the Tree."},
    {"NodeType const & ::genesis::tree::Tree::root_node () const", "Return the TreeNode at the current root of the Tree."},
    {"void ::genesis::tree::Tree::swap (TreeType & other)", "Swap."},

    {"std::string ::genesis::tree::TreeEdge::dump () const", "Returns a one-line dump summary of the data of this edge.\n\nTODO this method assumes that the tree node has a name. not good."},
    {"size_t ::genesis::tree::TreeEdge::index () const", "Return the index of this Link."},
    {"LinkType & ::genesis::tree::TreeEdge::primary_link ()", "Return the TreeLink of this TreeEdge that points towards the root."},
    {"LinkType const & ::genesis::tree::TreeEdge::primary_link () const", "Return the TreeLink of this TreeEdge that points towards the root."},
    {"NodeType & ::genesis::tree::TreeEdge::primary_node ()", "Return the TreeNode of this TreeEdge that points towards the root."},
    {"NodeType const & ::genesis::tree::TreeEdge::primary_node () const", "Return the TreeNode of this TreeEdge that points towards the root."},
    {"LinkType & ::genesis::tree::TreeEdge::secondary_link ()", "Return the TreeLink of this TreeEdge that points away from the root."},
    {"LinkType const & ::genesis::tree::TreeEdge::secondary_link () const", "Return the TreeLink of this TreeEdge that points away from the root."},
    {"NodeType & ::genesis::tree::TreeEdge::secondary_node ()", "Return the TreeNode of this TreeEdge that points away from the root."},
    {"NodeType const & ::genesis::tree::TreeEdge::secondary_node () const", "Return the TreeNode of this TreeEdge that points away from the root."},

    {"std::string ::genesis::tree::TreeLink::dump () const", "Return a string containing dump information about this link.\n\nAt the moment, a link does not contain any information, so an empty string is returned. This might change in the future, in case links also contain data."},
    {"EdgeType & ::genesis::tree::TreeLink::edge ()", "Return the TreeEdge of this TreeLink."},
    {"EdgeType const & ::genesis::tree::TreeLink::edge () const", "Return the TreeEdge of this TreeLink."},
    {"size_t ::genesis::tree::TreeLink::index () const", "Return the index of this Link."},
    {"bool ::genesis::tree::TreeLink::is_inner () const", "Return true iff the node of this link is an inner node."},
    {"bool ::genesis::tree::TreeLink::is_leaf () const", "Return true iff the node of this link is a leaf node."},
    {"LinkType & ::genesis::tree::TreeLink::next ()", "Return the next TreeLink within the TreeNode of this link."},
    {"LinkType const & ::genesis::tree::TreeLink::next () const", "Return the next TreeLink within the TreeNode of this link."},
    {"NodeType & ::genesis::tree::TreeLink::node ()", "Return the TreeNode of this TreeLink."},
    {"NodeType const & ::genesis::tree::TreeLink::node () const", "Return the TreeNode of this TreeLink."},
    {"LinkType & ::genesis::tree::TreeLink::outer ()", "Return the TreeLink of the adjacent TreeNode."},
    {"LinkType const & ::genesis::tree::TreeLink::outer () const", "Return the TreeLink of the adjacent TreeNode."},
    {"LinkType & ::genesis::tree::TreeLink::prev ()", "Return the previous TreeLink within the TreeNode of this link.\n\nThe previous link of a given link L is the one whose next-pointer is pointing to L. As this link first has to be found, this function is not as cheap as next()."},
    {"LinkType const & ::genesis::tree::TreeLink::prev () const", "Return the previous TreeLink within the TreeNode of this link.\n\nThe previous link of a given link L is the one whose next-pointer is pointing to L. As this link first has to be found, this function is not as cheap as next()."},

    {"std::string ::genesis::tree::TreeNode::dump () const", "Returns a one-line dump summary of the data of this node.\n\nTODO this method assumes that the tree node has a name. not good."},
    {"size_t ::genesis::tree::TreeNode::index () const", "Return the index of this Link."},
    {"bool ::genesis::tree::TreeNode::is_inner () const", "True iff the node is an inner node."},
    {"bool ::genesis::tree::TreeNode::is_leaf () const", "True iff the node is a leaf/tip."},
    {"LinkType & ::genesis::tree::TreeNode::link ()", "Return the TreeLink that points towards the root.\n\nThis is just an alias for primary_link(), that is shorter to use when needed frequently in an algorithm."},
    {"LinkType const & ::genesis::tree::TreeNode::link () const", "Return the TreeLink that points towards the root.\n\nThis is just an alias for primary_link(), that is shorter to use when needed frequently in an algorithm."},
    {"LinkType & ::genesis::tree::TreeNode::primary_link ()", "Return the TreeLink that points towards the root."},
    {"LinkType const & ::genesis::tree::TreeNode::primary_link () const", "Return the TreeLink that points towards the root."},
    {"size_t ::genesis::tree::TreeNode::rank () const", "Rank of the node, i.e. how many immediate children it has."},

    {"void ::genesis::tree::TreeSet::add (std::string const & name, TreeType const & tree)", "Add a Tree with a name to the TreeSet.\n\nThe Tree is copied."},
    {"void ::genesis::tree::TreeSet::clear ()", "Clear the TreeSet and destroy all contained Trees."},
    {"bool ::genesis::tree::TreeSet::empty () const", "Return whether the TreeSet is empty."},
    {"void ::genesis::tree::TreeSet::remove_at (size_t index)", "Remove the Tree at a certain index position.\n\nAs this function moves Trees in the container around, all iterators and pointers to the elements of this TreeSet are considered to be invalidated."},
    {"size_t ::genesis::tree::TreeSet::size () const", "Return the size of the TreeSet, i.e., the number of stored Trees."},



    {"size_t ::genesis::utils::Bitvector::count () const", "Counts the number of set bits in the Bitvector."},
    {"void ::genesis::utils::Bitvector::flip (size_t index)", "Flips (inverts) the value of a single bit, with boundary check."},
    {"bool ::genesis::utils::Bitvector::get (size_t index) const", "Returns the value of a single bit, with boundary check."},
    {"size_t ::genesis::utils::Bitvector::hash () const", "Returns an std::hash value for the Bitvector."},
    {"void ::genesis::utils::Bitvector::invert ()", "Flip all bits."},
    {"void ::genesis::utils::Bitvector::normalize ()", "Brings the Bitvector in a normalized form, where the first bit is always zero.\n\nIf the first bit is zero, nothing happens. However, if is is one, the whole Bitvector is flipped using invert()."},
    {"void ::genesis::utils::Bitvector::reset (const bool value=false)", "Reset all the bits to false. If provided with parameter true, sets all bits to true."},
    {"void ::genesis::utils::Bitvector::set (size_t index)", "Sets the value of a single bit to true, with boundary check."},
    {"void ::genesis::utils::Bitvector::set (size_t index, bool value)", "Sets the value of a single bit to a given bool value, with boundary check."},
    {"size_t ::genesis::utils::Bitvector::size () const", "Returns the size (number of total bits) of this Bitvector."},
    {"void ::genesis::utils::Bitvector::unset (size_t index)", "Sets the value of a single bit to false, with boundary check."},
    {"IntType ::genesis::utils::Bitvector::x_hash () const", "Returns a hash value of type IntType, that is quicker to calculate than hash(), and thus can be used where the std::hash is not needed."},

    {"bool ::genesis::utils::CharLookup::all_set () const", "Return whether all chars are set to true."},
    {"bool ::genesis::utils::CharLookup::all_unset () const", "Return whether all chars are set to false."},
    {"bool ::genesis::utils::CharLookup::get (char c) const", "Return the lookup status for a given char."},
    {"std::string ::genesis::utils::CharLookup::get_selection () const", "Return a std::string containg all chars which have lookup status true."},
    {"void ::genesis::utils::CharLookup::set_all (bool value=true)", "Set the lookup status for all chars at once.\n\nThe set value is true by default."},
    {"void ::genesis::utils::CharLookup::set_char (char c, bool value=true)", "Set the lookup status for a given char.\n\nThe set value is true by default."},
    {"void ::genesis::utils::CharLookup::set_if (std::function< bool(char)> predicate, bool value=true)", "Set the lookup status for all chars that fulfill a given predicate.\n\nThe set value is true by default."},
    {"void ::genesis::utils::CharLookup::set_range (char first, char last, bool value=true)", "Set the lookup status for all chars in an inlcuding range between two chars.\n\nThe set value is true by default."},
    {"void ::genesis::utils::CharLookup::set_selection (std::string const & chars, bool value=true)", "Set the lookup status for all chars that are contained in a given std::string.\n\nThe set value is true by default."},



    {"void ::genesis::utils::CountingIstream::advance ()", "Move to the next char in the stream and advance the counters."},
    {"void ::genesis::utils::CountingIstream::advance_non_counting ()", "Advance in the stream without updating the line and column counter.\n\nThis function is meant for fast parsers that do not want to keep track of the stream position but still use the interface of this class. Of course, after calling this function, the positions are out of sync."},
    {"std::string ::genesis::utils::CountingIstream::at () const", "Return a textual representation of the current input position in the form \"line:column\"."},
    {"size_t ::genesis::utils::CountingIstream::column () const", "Return the current column of the input stream.\n\nThe counter starts with column 1 for each line of the input stream. The value for default constructed objects (no stream provided) is 0, to be able to distinguish it from actual streams. New line characters \\n are included in counting and count as the last character of a line."},
    {"char ::genesis::utils::CountingIstream::current () const", "Return the current char, with char check.\n\nThis function is similar to the dereference operator, but additionally performs a check of the current char: This iterator is meant for ASCII (or similar) text format encodings, and its output should be usable for lookup tables etc. Thus, this function ensures that the char is in the range [0, 127]. If not, an std::domain_error is thrown."},
    {"bool ::genesis::utils::CountingIstream::eos () const", "Return true iff the input reached its end."},
    {"bool ::genesis::utils::CountingIstream::good () const", "Return true iff the input is good (not eof) and can be read from."},
    {"size_t ::genesis::utils::CountingIstream::line () const", "Return the current line of the input stream.\n\nThe counter starts with line 1 for input stream. The value for default constructed objects (no stream provided) is 0, to be able to distinguish it from actual streams."},

    {"T ::genesis::utils::Deserializer::get_float ()", "Read a floating point number from the stream and return it."},
    {"void ::genesis::utils::Deserializer::get_float (T & res)", "Read an floating point number from the stream and store it in the result."},
    {"T ::genesis::utils::Deserializer::get_int ()", "Read an integer number from the stream and return it."},
    {"void ::genesis::utils::Deserializer::get_int (T & res)", "Read an integer number from the stream and store it in the result."},
    {"bool ::genesis::utils::Deserializer::get_null (size_t n)", "Reads n bytes from the stream and returns whether all of them are \\0 bytes."},
    {"T ::genesis::utils::Deserializer::get_plain ()", "Read as many bytes from the stream as the type T holds, and return them in form of a value of type T."},
    {"void ::genesis::utils::Deserializer::get_plain (T & res)", "Read as many bytes from the stream as the type T holds, and put them in the result value of type T."},
    {"void ::genesis::utils::Deserializer::get_raw (char * buffer, size_t n)", "Read n bytes from the stream and store them in the buffer.\n\nThe buffer needs to be big enough to hold n bytes."},
    {"std::string ::genesis::utils::Deserializer::get_raw_string (size_t n)", "Read n bytes from the stream and return them as a string."},
    {"std::string ::genesis::utils::Deserializer::get_string ()", "Read a string from the stream, provided that its length it written preceding it, as done by put_string()."},







    {"void ::genesis::utils::JsonReader::from_file (const std::string & filename, JsonDocument & document) const", "Take a JSON document file path and parses its contents into a JsonDocument.\n\nIf the file does not exists, the function throws an std::runtime_error."},
    {"void ::genesis::utils::JsonReader::from_string (const std::string & json, JsonDocument & document) const", "Take a string containing a JSON document and parses its contents into a JsonDocument.\n\nReturns true iff successfull."},


    {"void ::genesis::utils::JsonValueArray::add (JsonValue * value)", "Alias of push_back()."},
    {"JsonValue * ::genesis::utils::JsonValueArray::at (const std::size_t index) const", "Provides index based array access to the array, doing a boundary check first.\n\nIn out of bounds cases, a nullptr is returned."},
    {"const_iterator ::genesis::utils::JsonValueArray::cbegin () const", "Const version of begin()."},
    {"const_iterator ::genesis::utils::JsonValueArray::cend () const", "Const version of end()."},
    {"void ::genesis::utils::JsonValueArray::clear ()", "Clears all values, as if the array was newly created."},
    {"bool ::genesis::utils::JsonValueArray::empty () const", "Returns whether the array is empty."},
    {"size_t ::genesis::utils::JsonValueArray::size () const", "Returns the number of values in the array."},




    {"JsonValue * ::genesis::utils::JsonValueObject::at (const std::string & name) const", "Provides index based array access to the object, doing a boundary check first. This is an alias for get().\n\nIn out of bounds cases, a nullptr is returned."},
    {"const_iterator ::genesis::utils::JsonValueObject::cbegin () const", "Const version of begin()."},
    {"const_iterator ::genesis::utils::JsonValueObject::cend () const", "Const version of end()."},
    {"void ::genesis::utils::JsonValueObject::clear ()", "Clears all values, as if the object was newly created."},
    {"bool ::genesis::utils::JsonValueObject::empty () const", "Returns whether the object is empty."},
    {"bool ::genesis::utils::JsonValueObject::erase (const std::string name)", "Clears the value of a specific key; returns true iff this key existed."},
    {"JsonValue * ::genesis::utils::JsonValueObject::get (const std::string & name) const", "Returns the value of a certain key if present in the object, nullptr otherwise."},
    {"bool ::genesis::utils::JsonValueObject::has (const std::string & name) const", "Returns true iff the object contains a certain key."},
    {"void ::genesis::utils::JsonValueObject::set (const std::string & name, JsonValue * value)", "Sets the value for a certain key."},
    {"size_t ::genesis::utils::JsonValueObject::size () const", "Returns the number of values in the object."},


    {"void ::genesis::utils::JsonWriter::to_file (JsonDocument const & document, std::string const & filename) const", "Write a JsonDocument to a file.\n\nIf the file already exists or cannot be written to, the function throws std::runtime_error."},
    {"void ::genesis::utils::JsonWriter::to_stream (JsonDocument const & document, std::ostream & out) const", "Write a JsonDocument to a stream."},
    {"void ::genesis::utils::JsonWriter::to_string (JsonDocument const & document, std::string & output) const", "Give the Json string representation of a JsonDocument."},
    {"std::string ::genesis::utils::JsonWriter::to_string (JsonDocument const & document) const", "Return the Json representation of a JsonDocument."},

    {"LexerToken ::genesis::utils::Lexer::back () const", "Returns a reference to the last token.\n\nCalling this function on an empty() lexer causes undefined behavior."},
    {"void ::genesis::utils::Lexer::clear ()", "Clears all tokens, as if the object was newly created.\n\nThe options of the lexer are however not changed."},
    {"std::string ::genesis::utils::Lexer::dump () const", "Returns a listing of the parse result in readable form."},
    {"bool ::genesis::utils::Lexer::empty () const", "Returns whether the list of tokens is empty.\n\nThis is usually the case before ProcessString() was run."},
    {"bool ::genesis::utils::Lexer::from_string (const std::string & in)", "Shortcut function that reads the contents of a file and then calls from_string().\n\nIf the file does not exist, a warning is triggered and false returned. Otherwise, the result of from_string() is returned. Process a string and store the resulting tokens in this Lexer object.This process analyzes and splits the string into different tokens. For the types of tokens being extracted, see LexerToken; for accessing the results, see Lexer.Returns true iff successful. In case an error is encountered while analyzing the text, this functions returns false and the last token will be of type LexerTokenType::kError, with the value being an error message describing the type of error."},
    {"bool ::genesis::utils::Lexer::has_error () const", "Returns whether there appeared an error while lexing."},
    {"bool ::genesis::utils::Lexer::process_step ()", "Processes one step of the lexing.\n\nAs stated in the description of this Lexer class, the class is meant to be derived for concrete types of lexers. Thus, here are some comments about the working of this function:For most types of structured text, the first character of each token determines the type of the token (for example, a digit almost always leads to a number token). This is why we use a list telling us which char leads to which token type. This list is a speedup, because using it, we do not need to try every scanner (for numbers, symbols, strings, etc) at the beginning of each new token, but simply do a lookup to find out \"this char means we have to use\nthis scanner now\". (Also see get_char_type and SetCharType for this.)This does not mean that any char of a given type can only appear in tokens of that type. For example, typically a symbol can start with letters, but then contain numbers later, too. Thus, although a digit is of type kNumber, it can end up in a symbol token, depending on the context.Instead, the char type here is meant as a speedup for finding the right scanner when lexing the text: whenever one scanner finishes, the next char is inspected and depending on its type, a fitting scanner is activated (for digits the number scanner and so on).This technique will not work if finding the correct scanner depends on more than the first character of the token. For example, comments usually start with a more complex sequence (\"//\" or even \"<!--\"), which is why they are specially treaded in this function.So, in situations, where the type of the next token cannot be determined from its first character (except comments), this function has to be overridden in the derived class in order to do some other checking methods to determine the correct scanner."},
    {"size_t ::genesis::utils::Lexer::size () const", "Returns the number of tokens produced during the analysis process."},
    {"bool ::genesis::utils::Lexer::validate_brackets () const", "Checkes whether the bracket tokes are validly nested.\n\nIn order to be valid, every opening bracket must be matched with a corresponding closing bracket, and their order has to be correct.This function checks the following types of brackets: () [] {} <>\nIt is not particularly useful for xml, as there it is also important to use closing tags like <xml> ... </xml>."},

    {"void ::genesis::utils::LexerIterator::consume_head ()", "Removes all tokens up to (but excluding) the current one.\n\nThis is a slow operation, thus should not be called in the inner parsing loop. It is meant to save memory when reading and parsing large files."},
    {"bool ::genesis::utils::LexerIterator::has_error () const", "Returns whether there appeared an error while lexing."},

    {"std::string ::genesis::utils::LexerToken::at () const", "Shortcut that returns \"line:column\" (e.g., for logging)."},
    {"size_t ::genesis::utils::LexerToken::column () const", "Getter for the column where this token occured."},
    {"size_t ::genesis::utils::LexerToken::has_new_lines () const", "Returns the number of new line characters, if this token is a whitespace."},
    {"bool ::genesis::utils::LexerToken::is_bracket () const", "Shortcut to check if this is a bracket token.\n\nThere is an overload of this function that also checks if the token is a specific type of bracket."},
    {"bool ::genesis::utils::LexerToken::is_bracket (const std::string & br) const", "Returns whether this token is a given type of bracket.\n\nUsage: token.is_bracket(\")\") will return true if this token is of LexerTokenType kBracket and if it is the closing parenthesis. This is a shortcut for testing type and value at the same time."},
    {"bool ::genesis::utils::LexerToken::is_comment () const", "Shortcut to check if this is a comment token."},
    {"bool ::genesis::utils::LexerToken::is_error () const", "Shortcut to check if this is an error token."},
    {"bool ::genesis::utils::LexerToken::is_number () const", "Shortcut to check if this is a number token."},
    {"bool ::genesis::utils::LexerToken::is_operator () const", "Shortcut to check if this is an operator token.\n\nThere is an overload of this function that also checks if the token is a specific type of operator."},
    {"bool ::genesis::utils::LexerToken::is_operator (const std::string & op) const", "Returns whether this token is a given type of operator.\n\nUsage: token.is_operator(\"%\") will return true if this token is of LexerTokenType kOperator and if it is the modulo operator. This is a shortcut for testing type and value at the same time."},
    {"bool ::genesis::utils::LexerToken::is_string () const", "Shortcut to check if this is a string token."},
    {"bool ::genesis::utils::LexerToken::is_symbol () const", "Shortcut to check if this is a symbol token."},
    {"bool ::genesis::utils::LexerToken::is_tag () const", "Shortcut to check if this is a tag token."},
    {"bool ::genesis::utils::LexerToken::is_unknown () const", "Shortcut to check if this is an unknown token."},
    {"bool ::genesis::utils::LexerToken::is_white () const", "Shortcut to check if this is a whitespace token."},
    {"size_t ::genesis::utils::LexerToken::line () const", "Getter for the line where this token occured."},
    {"LexerTokenType ::genesis::utils::LexerToken::type () const", "Getter for the LexerTokenType of this token."},
    {"std::string ::genesis::utils::LexerToken::type_to_string () const", "Returns the string representation for the LexerTokenType of this token."},
    {"std::string ::genesis::utils::LexerToken::value () const", "Getter for the string value of this token."},

    {"std::ostringstream & ::genesis::utils::Logging::get (const std::string & file, const int line, const std::string & function, const LoggingLevel level)", "Getter for the singleton instance of log, is called by the standard macros.\n\nIt returns the string stream buffer used to capture the log messages."},
    {"std::ostringstream & ::genesis::utils::Logging::get (const std::string & file, const int line, const std::string & function, const LoggingLevel level, const LoggingDetails dets)", "Getter for the singleton instance of log, is called by special macros that change the details of the log message.\n\nIt stores some relevant information and returns the string stream buffer used to capture the log messages."},
    {"static std::string ::genesis::utils::Logging::level_to_string (const LoggingLevel level)", "Return a string representation of a log level."},
    {"static void ::genesis::utils::Logging::log_to_file (const std::string & fn)", "Add an output file to which log messages are written.\n\nThis creates a stream to the file."},
    {"static void ::genesis::utils::Logging::log_to_stdout ()", "Add stdout as output stream to which log messages are written."},
    {"static void ::genesis::utils::Logging::log_to_stream (std::ostream & os)", "Add an output stream to which log messages are written."},
    {"static LoggingLevel ::genesis::utils::Logging::max_level ()", "Get the highest log level that is reported."},
    {"static void ::genesis::utils::Logging::max_level (const LoggingLevel level)", "Set the highest log level that is reported.\n\nInvocations of log with higher levels will create no output. It creates a warning if the set level is higher than the static compile time level set by LOG_LEVEL_MAX."},
    {"static int ::genesis::utils::Logging::report_percentage ()", "Get the current percentage for reporting LOG_PROG messages."},
    {"static void ::genesis::utils::Logging::report_percentage (const int percentage)", "set the percentage for reporting LOG_PROG messages."},









    {"std::vector< std::string > ::genesis::utils::Options::command_line () const", "Returns an array of strings containing the program's command line arguments."},
    {"std::string ::genesis::utils::Options::command_line_string () const", "Returns a string containing the program's command line arguments."},
    {"std::string ::genesis::utils::Options::dump () const", "Return a list of all options with their values."},
    {"static Options & ::genesis::utils::Options::get ()", "Returns a single instance of this class."},
    {"unsigned int ::genesis::utils::Options::number_of_threads () const", "Returns the number of threads."},
    {"std::default_random_engine & ::genesis::utils::Options::random_engine ()", "Returns the default engine for random number generation.\n\nCaveat: This is not intended for the use in more than one thread. As the order of execution in threads is not deterministic, results would not be reproducible, even when using a fixed seed. Furthermore, it might be a speed bottleneck to add a mutex to this method.If in the furture there is need for multi-threaded random engines, they needed to be outfitted with separate seeds each (otherwise they would all produce the same results). Thus, for now we simply assume single-threaded use."},
    {"unsigned ::genesis::utils::Options::random_seed () const", "Returns the random seed that was used to initialize the engine."},
    {"void ::genesis::utils::Options::set_command_line (const int argc, const char * argv)", "Set arguments to the program's command line options.\n\nIf the program is run from the command line, this method has to be used to properly propagate the command line options to this options class."},
    {"void ::genesis::utils::Options::set_number_of_threads (const unsigned int number)", "Overwrite the system given number of threads.\n\nOn startup, the value is initialized with the actual number of cores available in the system using std::thread::hardware_concurrency(). This method overwrites this value."},
    {"void ::genesis::utils::Options::set_random_seed (const unsigned seed)", "Set a specific seed for the random engine.\n\nOn startup, the random engine is initialized using the current system time. This value can be overwritten using this method."},


    {"void ::genesis::utils::Serializer::put_float (const T v)", "Write a floating point number to the stream.\n\nCurrently, this simply uses put_plain(), but future versions might change this behaviour and convert it to some machine-independent format."},
    {"void ::genesis::utils::Serializer::put_int (const T v)", "Write an integer number to the stream.\n\nCurrently, this simply uses put_plain(), but future versions might change this behaviour and use specific conversions (litte/big endianness, signed/unsigned) before writing."},
    {"void ::genesis::utils::Serializer::put_null (const size_t n)", "Write n zero bytes (\\0) to the stream."},
    {"void ::genesis::utils::Serializer::put_plain (const T v)", "Write plain data to the stream, by casting it to a char array."},
    {"void ::genesis::utils::Serializer::put_raw (char * data, size_t n)", "Write raw data, provided as a char array of length n, to the stream."},
    {"void ::genesis::utils::Serializer::put_raw_string (const std::string & v)", "Write raw data, provided as a string, to the stream, without writing its length."},
    {"void ::genesis::utils::Serializer::put_string (const std::string & v)", "Write a string, preceded by its length, to the stream. Use get_string() to read it."},

    {"bool ::genesis::utils::Style::bold () const", "Return whether the Style uses bold."},
    {"Style & ::genesis::utils::Style::bold (bool value)", "Set whether the Style uses bold.\n\nThe function returns the Style object itself, in order to allow a fluent interface."},
    {"bool ::genesis::utils::Style::enabled () const", "Return whether the Style is currently enabled."},
    {"Style & ::genesis::utils::Style::enabled (bool value)", "Set whether the Style is enabled.\n\nIf set to false, no style attributes are outputted when the Style is applied to a text with operator()(). Default is true.The function returns the Style object itself, in order to allow a fluent interface."},
    {"static std::string ::genesis::utils::Style::get_background_color_value (std::string name)", "Return the color value string for a given background color name.\n\nSee Style::foreground_colors for background valid color names. If the name is invalid, the function throws an std::out_of_range exception."},
    {"static std::string ::genesis::utils::Style::get_foreground_color_value (std::string name)", "Return the color value string for a given foreground color name.\n\nSee Style::foreground_colors for valid foreground color names. If the name is invalid, the function throws an std::out_of_range exception."},
    {"static bool ::genesis::utils::Style::is_background_color (std::string name)", "Return true iff the given name is a background color name."},
    {"static bool ::genesis::utils::Style::is_foreground_color (std::string name)", "Return true iff the given name is a foreground color name."},
    {"Style & ::genesis::utils::Style::reset ()", "Reset the Style to use not colors and not bold."},
    {"std::string ::genesis::utils::Style::to_bash_string (std::string const & text) const", "Additional output function with the same purpose as operator().\n\nIt uses the notation \\033 for the escape symbol, which is best interpreted by bash. Usually, there is no need to use this function. The operator() should just work fine."},
    {"std::string ::genesis::utils::Style::to_python_string (std::string const & text) const", "Additional output function with the same purpose as operator().\n\nIt uses the notation \\x1b for the escape symbol, which is best interpreted by python. Usually, there is no need to use this function. The operator() should just work fine."},

    {"Column & ::genesis::utils::Table::add_column (std::string label="")", "Add a column to the table.\n\nIf the table already contains columns with data, the new one is initialized with empty strings for the whole length of the table."},
    {"void ::genesis::utils::Table::clear ()", "Clears all columns and their data from the table."},
    {"void ::genesis::utils::Table::clear_content ()", "Clears the data contents of all columns. Their labels etc stay unchanged."},







    {"void ::genesis::utils::XmlWriter::to_file (const XmlDocument & document, const std::string & filename)", "Write an XML file from an XmlDocument. Return true iff successful.\n\nIf the file already exists, the function throws std::runtime_error. The function uses utils::file_write. See there for other exceptions that can be thrown."},
    {"void ::genesis::utils::XmlWriter::to_string (const XmlDocument & document, std::string & output)", "Give the XML string representation of a XmlDocument."},
    {"std::string ::genesis::utils::XmlWriter::to_string (const XmlDocument & document)", "Return the XML representation of a XmlDocument."},


    {"void ::genesis::utils::Table::Column::shrink_width ()", "Shrinks the column width to the minmal width that suffices to fit in all values of the column (i.e., both data and label).\n\nThe column keeps track of its needed minimal width when just adding data. Thus, this function is only neccessary to call once the width was changed manually or if the label or a data value have been changed after being added."},
    {"void ::genesis::utils::Table::Column::width (size_t value)", "Set the width of this column.\n\nIf the new value is smaller than the current one, nothing happens. The width can only grow, or be set to the minimal possible value using shrink_width(). This ensures that all text fits within the column."},



    {"bool ::genesis::utils::char_match_ci (const char c1, const char c2)", "Returns whether two chars are the same, case insensitive."},
    {"void ::genesis::utils::expect_char (utils::CountingIstream & source, char criterion)", "Lexing function that checks whether the current char from the stream equals the provided one. If not, the function throws std::runtime_error."},
    {"void ::genesis::utils::expect_char (utils::CountingIstream & source, std::function< bool(char)> criterion)", "Lexing function that checks whether the current char from the stream fulfills the provided criterion. If not, the function throws std::runtime_error."},
    {"Color ::genesis::utils::color_from_doubles (double r, double g, double b)", "Create a Color given three doubles in the range [0.0, 1.0] for each of the components red, green and blue."},
    {"Color ::genesis::utils::color_from_hex (std::string h, std::string prefix)", "Create a Color given a hex color string in the format \"#0033ff\".\n\nThe hash sign in the beginning can be replaced by any given prefix. If the string is not correctly formatted, an std::invalid_argument exception is thrown."},
    {"std::string ::genesis::utils::color_to_hex (const Color & c, std::string prefix, bool uppercase)", "Return a hex string representation of a Color in the format \"#0033ff\".\n\nThe hash sign in the beginning can be replaced by any given prefix. If uppercase is set to true, any outputted alphabetical chars (between A and F for hex strings) will be uppercase."},
    {"size_t ::genesis::utils::count_substring_occurrences (std::string const & str, std::string const & sub)", "Return the number of non-overlapping occurrences of a substring in a string."},
    {"std::string ::genesis::utils::current_date ()", "Returns the current date as a string in the format \"2014-12-31\"."},
    {"std::string ::genesis::utils::current_time ()", "Returns the current time as a string in the format \"13:37:42\"."},
    {"std::string ::genesis::utils::deescape (std::string const & text)", "Return a string where the escaped characters are transformed into their respective string form.\n\nFor example, the escape sequence \\n (backshlash n) will be translated into a new line. The same applies for tabs and carrier returns. All other escaped sequences will simply translate into the second char, e.g., a double backslash will become one backslash."},
    {"void ::genesis::utils::dir_create (std::string const & path)", "Create a directory.\n\nIf the directory already exists, nothing happens. If the path exists, but is not a directory, a std::runtime_error is thrown. If the creation fails for some other reason, also a std::runtime_error is thrown."},
    {"bool ::genesis::utils::dir_exists (std::string const & dir)", "Return true iff the directory exists."},
    {"std::vector< std::string > ::genesis::utils::dir_list_files (std::string const & dir)", "Get a list of files in a directory.\n\nIf the directory is not readable, the function throws std::runtime_error."},
    {"bool ::genesis::utils::equals_ci (std::string const & lhs, std::string const & rhs)", "Compare two strings case insensitive."},
    {"std::string ::genesis::utils::escape (std::string const & text)", "Return a string where special chars are replaces by their escape sequence.\n\nAll new lines are transformed into either \\r or \\n, tabs into \\t. Double quotation marks are preceeded by a backslash, also the backslash itself will be escaped, so that \"</tt> becomes <tt>\\\\\" and \\ becomes \\\\."},
    {"void ::genesis::utils::file_append (std::string const & content, std::string const & filename)", "Append the content of a string to a file.\n\nIf the file is not writable, the function throws std::runtime_error."},
    {"std::string ::genesis::utils::file_basename (std::string filename)", "Remove directory name from file name if present."},
    {"bool ::genesis::utils::file_exists (std::string const & filename)", "Return true iff the file exists."},
    {"std::string ::genesis::utils::file_extension (std::string filename)", "Return the extension name of a file.\n\nAlso see file_filename()."},
    {"std::string ::genesis::utils::file_filename (std::string filename)", "Remove extension if present.\n\nCaveat: Does not remove the path. So, if the filename itself does not contain an extension separator \".\", but the path does, this will yield an unwanted result. Call file_basename() first."},
    {"std::unordered_map< std::string, std::string > ::genesis::utils::file_info (std::string const & filename)", "Return information about a file."},
    {"std::string ::genesis::utils::file_path (std::string filename)", "Return the path leading to a file.\n\nDoes not resolve the path. Simply splits at the last directory separator."},
    {"std::string ::genesis::utils::file_read (std::string const & filename)", "Return the contents of a file as a string.\n\nIf the file is not readable, the function throws std::runtime_error."},
    {"size_t ::genesis::utils::file_size (std::string filename)", "Return the size of a file."},
    {"void ::genesis::utils::file_write (std::string const & content, std::string const & filename)", "Write the content of a string to a file.\n\nIf the file is not writable, the function throws std::runtime_error."},
    {"std::string ::genesis::utils::get_attribute_string (Style const & s)", "Internal helper function that returns the attribute string of a Style based on its properties."},
    {"static std::array< std::pair< std::string, std::string >, 17 >::const_iterator ::genesis::utils::get_background_color_iterator (std::string name)", "Internal helper function that returns an iterator into the background color list."},
    {"static std::array< std::pair< std::string, std::string >, 17 >::const_iterator ::genesis::utils::get_foreground_color_iterator (std::string name)", "Internal helper function that returns an iterator into the foreground color list."},
    {"Color ::genesis::utils::get_named_color (std::string const & name)", "Retrieve a named color by name.\n\nNames are filtered so that spaces, underscores and the letter case are ignored. If the color name does not exist, an std::invalid_argument exception is thrown."},
    {"std::array< std::pair< std::string, Color >, 140 >::const_iterator ::genesis::utils::get_named_color_iterator (std::string name)", "Internal helper function.\n\nReturns an iterator into the array if the given name is a named color or an iterator to the end of the color map if it is not a named color."},
    {"Color ::genesis::utils::gradient (std::map< double, Color > const & ranges, double percentage)", "Returns a Color that is created using a color gradient.\n\nThe function takes a color gradient in form of a map from double to Color. The keys in the map are offset positions between 0.0 and 1.0. The keys 0.0 and 1.0 need to be the lowest and highest keys in the map, respectively. Otherwise, an std::invalid_argument is thrown. An arbitrary number of keys in between these boundaries is allowed.Each key is associated with a Color value, which indicates the color at that position.Example: // Prepare gradient ranges.\nauto ranges = std::map<double, Color>();\nranges[ 0.0 ] = Color(   0, 255, 0 );\nranges[ 0.5 ] = Color( 255, 255, 0 );\nranges[ 1.0 ] = Color( 255,   0, 0 );\n\n// Get color at 30% of the green-yellow-red gradient.\nColor c = gradient( ranges, 0.3 );\nThis map defines the same gradient that is used for heat_gradient.The second parameter of this function then takes the position (again, between 0.0 and 1.0) at which the gradient is evaluated. Values outside of the interval [0.0, 1.0] are set to the closest interval border value (so, either 0.0 or 1.0).For example, given the range map above, a percentage value of 0.0 gives green; 0.5 gives yellow; 1.0 gives red; values in between are interpolated accordingly."},
    {"Color ::genesis::utils::heat_gradient (double percentage)", "Returns a Color that represents a heat gradient for a percentage value.\n\nGiven a percentage value in the range of [0.0, 1.0], the functions represents the heat of that value. For 0.0, the heat gradient value is green, for 0.5 yellow and for 1.0 red. The values in between are interpolated accordingly."},
    {"unsigned char ::genesis::utils::interpolate (unsigned char d1, unsigned char d2, double fraction)", "Helper function that linearily interpolates between two char values."},
    {"Color ::genesis::utils::interpolate (Color color1, Color color2, double fraction)", "Helper function that linearily interpolates between two Colors."},
    {"bool ::genesis::utils::is_named_color (std::string const & name)", "Return true iff the given name is a named color.\n\nNames are filtered so that spaces, underscores and the letter case are ignored."},
    {"JsonValueArray * ::genesis::utils::json_value_to_array (const JsonValue * v)", "Converts a pointer to a JsonValue to JsonValueArray if appropriate.\n\nTriggers a warning and returns a nullptr if the dynamic type of the object is not actually a JsonValueArray object."},
    {"JsonValueBool * ::genesis::utils::json_value_to_bool (const JsonValue * v)", "Converts a pointer to a JsonValue to JsonValueBool if appropriate.\n\nTriggers a warning and returns a nullptr if the dynamic type of the object is not actually a JsonValueBool object."},
    {"JsonValueNull * ::genesis::utils::json_value_to_null (const JsonValue * v)", "Converts a pointer to a JsonValue to JsonValueNull if appropriate.\n\nTriggers a warning and returns a nullptr if the dynamic type of the object is not actually a JsonValueNull object."},
    {"JsonValueNumber * ::genesis::utils::json_value_to_number (const JsonValue * v)", "Converts a pointer to a JsonValue to JsonValueNumber if appropriate.\n\nTriggers a warning and returns a nullptr if the dynamic type of the object is not actually a JsonValueNumber object."},
    {"JsonValueObject * ::genesis::utils::json_value_to_object (const JsonValue * v)", "Converts a pointer to a JsonValue to JsonValueObject if appropriate.\n\nTriggers a warning and returns a nullptr if the dynamic type of the object is not actually a JsonValueObject object."},
    {"JsonValueString * ::genesis::utils::json_value_to_string (const JsonValue * v)", "Converts a pointer to a JsonValue to JsonValueString if appropriate.\n\nTriggers a warning and returns a nullptr if the dynamic type of the object is not actually a JsonValueString object."},
    {"std::string ::genesis::utils::lexer_token_type_to_string (const LexerTokenType t)", "Converts a LexerTokenType into its string representation."},
    {"long ::genesis::utils::LoggingProgressValue (long value=-1)", "Hack function to make sure that the value arugment in LOG_PROG is only evaluated once.\n\nWithout this function, LOG_PROG would include two appearances of its variable value, which means that a statement like LOG_PROG(++i, n) << \"of progress.\";\nwould lead to a double evaluation of the increment statement ++i. That is not intended, thus we need this hack function."},
    {"double ::genesis::utils::mean (const Histogram & h)", "Compute the bin-weighted arithmetic mean.\n\nThe histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width."},
    {"Bitvector ::genesis::utils::operator- (Bitvector const & lhs, Bitvector const & rhs)", "Set-minus of two Bitvectors."},
    {"std::ostream & ::genesis::utils::operator<< (std::ostream & os, const Color & color)", "Write a textual representation of the Color the a stream, in the format \"(r, g, b)\"."},
    {"std::ostream & ::genesis::utils::operator<< (std::ostream & out, Style const & style)", "Print the properties of a Style object to a stream.\n\nThe application of Styles is usually done by invoking its operator(). However, in order to be able to show its properties at a glance, this operator instead prints them: Style s( \"blue\" );\nstd::cout << s;\nwill print this information instead of a stylized text."},
    {"T ::genesis::utils::parse_float (utils::CountingIstream & source)", "Read a floating point number from a stream and return it.\n\nThe number is expected to be in the following format: [+-]123[.456][eE[+-]789]\nThe function stops reading at the first non-fitting digit. It throws an std::overflow_error or underflow_error in case that the exponent (the part after the 'E') does not fit into integer value range."},
    {"T ::genesis::utils::parse_integer (utils::CountingIstream & source)", "Alias for parse_signed_integer()."},
    {"std::string ::genesis::utils::parse_quoted_string (utils::CountingIstream & source, bool use_escapes=true, bool include_qmarks=false)", "Read a string in quotation marks from a stream and return it.\n\nThe first char of the stream is considered to be the opening quotation mark. Everything up until the closing quotation mark (the same char again, whatever it is) is then read.If the optional parameter use_escapes is set to true, chars preceeded by a backslash are considered to be \"escaped\". The chars \\r, \\n and \\t are then turned into their respective white space equivalents, while all other chars are copied verbatim to the return string. Thus, by escaping it, a the string can also include the quotation mark itself. Default of this parameter is true.The optional parameter include_qmarks demtermines whether the quotation marks are included in the output or not. Default is false.If the string ends prematurely, i.e., without the closing quotation mark, or right after a backslash if use_escapes is used, the function throws an std::runtime_error."},
    {"T ::genesis::utils::parse_signed_integer (utils::CountingIstream & source)", "Read a signed integer from a stream and return it.\n\nThe function expects a sequence of digits, possibly with a leading + or -. It stops reading at the first non-digit. In case the value range is too small, the function throws std::overflow_error, or underflow_error, respectively."},
    {"T ::genesis::utils::parse_unsigned_integer (utils::CountingIstream & source)", "Read an unsigned integer from a stream and return it.\n\nThe function expects a sequence of digits. It stops reading at the first non-digit. In case the value range is too small, the function throws std::overflow_error."},
    {"char ::genesis::utils::read_char_if (utils::CountingIstream & source, char criterion)", "Lexing function that reads a single char from the stream and checks whether it equals the provided one. If not, the function throws std::runtime_error. The stream is advanced by one position and the char is returned."},
    {"char ::genesis::utils::read_char_if (utils::CountingIstream & source, std::function< bool(char)> criterion)", "Lexing function that reads a single char from the stream and checks whether it fulfills the provided criterion. If not, the function throws std::runtime_error. The stream is advanced by one position and the char is returned."},
    {"std::string ::genesis::utils::read_until (utils::CountingIstream & source, char criterion)", "Lexing function that reads from the stream until its current char equals the provided one. The read chars are returned."},
    {"std::string ::genesis::utils::read_until (utils::CountingIstream & source, std::function< bool(char)> criterion)", "Lexing function that reads from the stream until its current char fulfills the provided criterion. The read chars are returned."},
    {"std::string ::genesis::utils::read_while (utils::CountingIstream & source, char criterion)", "Lexing function that reads from the stream while its current char equals the provided one. The read chars are returned."},
    {"std::string ::genesis::utils::read_while (utils::CountingIstream & source, std::function< bool(char)> criterion)", "Lexing function that reads from the stream while its current char fulfills the provided criterion. The read chars are returned."},
    {"std::string ::genesis::utils::replace_all (std::string const & text, std::string const & search, std::string const & replace)", "Return a copy of a string, where all occurences of a search string are replaced by a replace string."},
    {"double ::genesis::utils::sigma (const Histogram & h)", "Compute the bin-weighted standard deviation.\n\nThe histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width."},
    {"void ::genesis::utils::skip_until (utils::CountingIstream & source, char criterion)", "Lexing function that advances the stream unts its current char equals the provided one."},
    {"void ::genesis::utils::skip_until (utils::CountingIstream & source, std::function< bool(char)> criterion)", "Lexing function that advances the stream until its current char fulfills the provided criterion."},
    {"void ::genesis::utils::skip_while (utils::CountingIstream & source, char criterion)", "Lexing function that advances the stream while its current char equals the provided one."},
    {"void ::genesis::utils::skip_while (utils::CountingIstream & source, std::function< bool(char)> criterion)", "Lexing function that advances the stream while its current char fulfills the provided criterion."},
    {"std::vector< std::string > ::genesis::utils::split (std::string const & str, std::string const & delimiters, const bool trim_empty)", "Spilt a string int parts, given a set of delimiter chars.\n\nThe string str is split using any of the chars in delimiters and returned as a vector of strings. If trim_empty is set, empty strings resulting from adjacent delimiter chars are excluded from the output."},
    {"std::string ::genesis::utils::to_lower (std::string const & str)", "Return an all-lowercase copy of the given string."},
    {"std::string ::genesis::utils::to_string_precise (double value, const int precision)", "Return a precise(er than to_string) string representation of the input value."},
    {"std::string ::genesis::utils::to_upper (std::string const & str)", "Return an all-uppercase copy of the given string."},
    {"std::string ::genesis::utils::trim (std::string const & s, std::string const & delimiters)", "Return a copy of the input string, with trimmed white spaces."},
    {"std::string ::genesis::utils::trim_left (std::string const & s, std::string const & delimiters)", "Return a copy of the input string, with right trimmed white spaces."},
    {"std::string ::genesis::utils::trim_right (std::string const & s, std::string const & delimiters)", "Return a copy of the input string, with left trimmed white spaces."},
    {"const XmlComment * ::genesis::utils::xml_value_to_comment (const XmlValue * v)", "Converts a pointer to an XmlValue to XmlComment if appropriate.\n\nTriggers a warning and returns a nullptr if the dynamic type of the object is not actually an XmlComment object."},
    {"const XmlElement * ::genesis::utils::xml_value_to_element (const XmlValue * v)", "Converts a pointer to an XmlValue to XmlElement if appropriate.\n\nTriggers a warning and returns a nullptr if the dynamic type of the object is not actually an XmlElement object."},
    {"const XmlMarkup * ::genesis::utils::xml_value_to_markup (const XmlValue * v)", "Converts a pointer to an XmlValue to XmlMarkup if appropriate.\n\nTriggers a warning and returns a nullptr if the dynamic type of the object is not actually an XmlMarkup object."},
    {"bool ::genesis::utils::char_is_digit (const char c)", "Returns whether a char is a digit (0-9)."},
    {"bool ::genesis::utils::char_is_sign (const char c)", "Returns whether a char is a sign (+-)."},
    {"bool ::genesis::tree::equal (const TreeTypeL & lhs, const TreeTypeR & rhs, std::function< bool(const typename TreeTypeL::NodeType &, const typename TreeTypeR::NodeType &) > node_comparator, std::function< bool(const typename TreeTypeL::EdgeType &, const typename TreeTypeR::EdgeType &) > edge_comparator)", "Compares two trees for equality given binary comparator functionals for their nodes and edges.\n\nThis function does a preorder traversal of both trees in parallel and calls the comparator functionals for each position of the iterator. It returns true iff the comparator is true for every position.The comparator functionals can be either function pointers, function objects, or lambda expressions.As the traversal is done in parallel, the trees are also checked for equal topology: their elements (links, nodes, edges) have to be equal in size and the rank of each node during the traversal has to be identical in both trees. Those assumptions are made because two trees that do not have identical topology are never considered equal."},
    {"bool ::genesis::tree::equal (const TreeTypeL & lhs, const TreeTypeR & rhs)", "Compares two trees for equality using the respective comparision operators for their nodes and edges.\n\nThis method is mainly a shortcut for the other equal function, where the comparator functionals are instanciated using the default comparision operators of the tree's data."},
    {"TreeType::NodeType * ::genesis::tree::find_node (TreeType & tree, const std::string & name, bool replace_underscores=false)", "Finds a Node, given its name. If not found, nullptr is returned."},
    {"double ::genesis::tree::height (const Tree & tree)", "Returns the height of the tree (longest distance from root to a leaf)."},
    {"bool ::genesis::tree::identical_topology (const TreeTypeL & lhs, const TreeTypeR & rhs)", "Returns true iff both trees have an identical topology.\n\nThe topology is considered identical only if the order of edges is also the same in both trees. This means, although two trees might have the same number of leaves and branches, they might still be not identical (with respect to this function) when the branches appear in a different order or when the root sits at a different node."},
    {"size_t ::genesis::tree::inner_node_count (Tree const & tree)", "Count the number of inner nodes."},
    {"bool ::genesis::tree::is_bifurcating (Tree const & tree)", "Return whether the Tree is bifurcating."},
    {"size_t ::genesis::tree::leaf_node_count (Tree const & tree)", "Count the number of leaf nodes of a Tree."},
    {"double ::genesis::tree::length (const Tree & tree)", "Returns the length of the tree (sum of all branch lengths)."},
    {"int ::genesis::tree::max_rank (Tree const & tree)", "Return the highest rank of the nodes of the Tree."},
    {"utils::Matrix< int > ::genesis::tree::node_depth_matrix (const Tree & tree)", "The vector is indexed using the node().index() for every node."},
    {"std::vector< int > ::genesis::tree::node_depth_vector (const Tree & tree, const typename Tree::NodeType * node=nullptr)", "Returns a vector containing the depth of all nodes with respect to the given start node.\n\nThe vector is indexed using the node().index() for every node. Its elements give the depth of each node with respect to the given start node. The depth is the number of edges visited on the path between two nodes (0 for itself, 1 for immediate neighbours, etc).If no start node pointer is provided, the root is taken as node."},
    {"utils::Matrix< double > ::genesis::tree::node_distance_matrix (const Tree & tree)", "Returns a distance matrix containing pairwise distances between all Nodes, using the branch_length of the Edges as distance measurement.\n\nThe elements of the matrix are indexed using node().index()."},
    {"std::vector< double > ::genesis::tree::node_distance_vector (const Tree & tree, const typename Tree::NodeType * node=nullptr)", "Returns a vector containing the distance of all nodes with respect to the given start node.\n\nThe vector is indexed using the node().index() for every node. Its elements give the distance of each node with respect to the given start node. The distance is the sum of branch lengths of the edges visited on the path between the two nodes.If no Node pointer is provided, the root is taken as node."},
    {"std::vector< std::string > ::genesis::tree::node_names (TreeType & tree, bool leaves_only=false)", "Returns a list of all node names of a Tree.\n\nIf leaves_only is set to true, nodes names of inner nodes are not included. Unnamed nodes (node.data.name == \"\") are always excluded."},
    {"bool ::genesis::tree::parse_newick_tree (NewickLexer::iterator & ct, const NewickLexer::iterator & end, NewickBroker & broker)", "Takes a NewickLexer in form of iterators and parses its tokens into a NewickBroker.\n\nThis function uses a pair of iterators to lexer tokens in order to process the tree, because for files with multiple trees in them (for example, when reading a TreeSet), this function has to be called with a new broker for each tree. This means, we cannot take the lexer as a whole but have to provide more finely grained access to its elements for this funtion."},
    {"std::vector< std::pair< const typename Tree::NodeType *, int > > ::genesis::tree::closest_leaf_depth_vector (const Tree & tree)", "Returns a vector containing the closest leaf node for each node, measured in number of edges between them and its depth (number of edges between them).\n\nThe vector is indexed using the node().index() for every node. Its value contains an std::pair, where the first element is a NodeType* to the closest leaf node (with respect to its depth) and the second element its depth with respect to the node at the given index of the vector. The depth is the number of edges visited on the path between two nodes (0 for itself, 1 for immediate neighbours, etc).Thus, leaf nodes will have a pointer to themselves and a depth value of 0, and for all other nodes the depth will be the number of edges between it and the closest leaf node.There might be more than one leaf with the same depth to a given node. In this case, an arbitrary one is used."},
    {"std::vector< std::pair< const typename Tree::NodeType *, double > > ::genesis::tree::closest_leaf_distance_vector (const Tree & tree)", "Returns a vector containing the closest leaf node for each node, using the branch_length as distance measure.\n\nThe vector is indexed using the node().index() for every node. Its value contains an std::pair, where the first element is a NodeType* to the closest leaf node of the node at the index, measured using the branch_length; the second element of the pair is the distance value itself. Thus, leaf nodes will have a pointer to themselves and a distance value of 0."},
    {"double ::genesis::tree::deepest_distance (const Tree & tree)", "Returns the longest distance from any point in the tree (on the edges) to any leaf."},
    {"std::ostream & ::genesis::sequence::operator<< (std::ostream & out, Sequence const & seq)", "Print a Sequence to an ostream in the form \"label: sites\".\n\nAs this is meant for quickly having a look at the Sequence, only the first 100 sites are printed. If you need all sites, use print()."},
    {"std::ostream & ::genesis::sequence::operator<< (std::ostream & out, SequenceSet const & set)", "Print a SequenceSet to an ostream in the form \"label: sites\".\n\nAs this is meant for quickly having a look at the SequenceSet, only the first 10 Sequences and the first 100 sites of each are printed. If you need all sequences and sites, use print()."},
    {"std::string ::genesis::sequence::print (Sequence const & seq, bool print_label, size_t length_limit)", "Return a Sequence in textual form.\n\nIf the optional parameter print_label is true, a label is printed before the sequence in the form \"label: sites\". Default is true.The optional parameter length_limit limites the output lenght to that many chars. If set to 0, the whole Sequence is printed. Default is 100. This is useful to avoid line wrapping. If the limit is lower than the acutal number of sites, ellipsis \" ...\" are appended."},
    {"std::string ::genesis::sequence::print (SequenceSet const & set, bool print_label, size_t length_limit, size_t sequence_limit)", "Return a Sequence in textual form.\n\nSee the Sequence version of this function for details. If the additional parameter sequence_limit is set to a value other than 0, only this number of sequences are printed. Default is 10. If the given limit is lower than the acutal number of sequences, ellipsis \" ...\" are appended."},
    {"std::string ::genesis::sequence::print_color (Sequence const & seq, std::map< char, std::string > const & colors, bool print_label, size_t length_limit, bool background)", "Return a string with the sites of the Sequence colored.\n\nThis function returns a color view of the sites of the given Sequence, using utils::Style colors, which can be displayed in a console/terminal. This is useful for visualizing the Sequence similar to graphical alignment and sequence viewing tools.The function takes a map from sequences characters to their colors (see utils::Style for a list of the available ones). The presettings nucleic_acid_text_colors() and amino_acid_text_colors() for default sequence types can be used as input for this parameter. If the colors map does not contain a key for one of the chars in the sequence, the function throws an std::out_of_range exception.The optional paramter print_label determines whether the sequence label is to be printed. Default is true.The optional parameter length_limit limites the output lenght to that many chars. If set to 0, the whole Sequence is used. Default is 100. This is useful to avoid line wrapping. If the limit is lower than the acutal number of sites, ellipsis \" ...\" are appended.The parameter background can be used to control which part of the output is colored: true (default) colors the text background and makes the foreground white, while false colors the foreground of the text and leaves the background at its default."},
    {"std::string ::genesis::sequence::print_color (SequenceSet const & set, std::map< char, std::string > const & colors, bool print_label, size_t length_limit, size_t sequence_limit, bool background)", "Return a string with the sites of a SequenceSet colored.\n\nSee the Sequence version of this function for details.The additional parameter sequence_limit controls the number of sequences to be printed. If set to 0, everything is printed. Default is 10. If this limit is lower than the actual number of sequences, ellipsis \" ...\" are appended.Be aware that each character is colored separately, which results in a lot of formatted output. This might slow down the terminal if too many sequences are printed at once."},
    {"void ::genesis::sequence::print_to_ostream (std::ostream & out, Sequence const & seq, std::map< char, std::string > const & colors, bool print_label, size_t length_limit, bool background)", "Local helper function for ostream and print to print one Sequence.\n\nSee the print() functions for details about the parameters."},
    {"void ::genesis::sequence::print_to_ostream (std::ostream & out, SequenceSet const & set, std::map< char, std::string > const & colors, bool print_label, size_t length_limit, size_t sequence_limit, bool background)", "Local helper function for ostream and print to print a SequenceSet.\n\nSee the print() functions for details about the parameters."},
    {"std::map< char, size_t > ::genesis::sequence::site_histogram (Sequence const & seq)", "Get a histogram of the occurrences of particular sites, given a Sequence.\n\nThis gives the raw counts of how often each site (character) appears in the Sequence. See base_frequencies() for the relative version of this function."},
    {"std::map< char, size_t > ::genesis::sequence::site_histogram (SequenceSet const & set)", "Get a histogram of the occurrences of particular sites, given a SequenceSet.\n\nThis gives the raw counts of how often each site (character) appears in the whole set. See base_frequencies() for the relative version of this function."},
    {"size_t ::genesis::sequence::total_length (SequenceSet const & set)", "Return the total length (sum) of all sequences in the set."},
    {"std::string ::genesis::sequence::translate_amino_acid (char code)", "Get the name of a amino acid given its IUPAC code.\n\nThe codes are translated as follows: A Alanine\nB Aspartic acid or Asparagine\nC Cysteine\nD Aspartic acid\nE Glutamic acid\nF Phenylalanine\nG Glycine\nH Histidine\nI Isoleucine\nJ Leucine or Isoleucine\nK Lysine\nL Leucine\nM Methionine\nN Asparagine\nO Pyrrolysine\nP Proline\nQ Glutamine\nR Arginine\nS Serine\nT Threonine\nU Selenocysteine\nV Valine\nW Tryptophan\nY Tyrosine\nZ Glutamic acid or Glutamine\nX any\n* translation stop\n- gap\n? gap\nThe code char is treated case-insensitive. If the given code char is not valid, an std::out_of_range exception is thrown."},
    {"std::string ::genesis::sequence::translate_nucleic_acid (char code)", "Get the name of a nucleic acid given its IUPAC code.\n\nThe codes are translated as follows: A Adenine\nC Cytosine\nG Guanine\nT Thymine\nU Uracil\nW Weak\nS Strong\nM aMino\nK Keto\nR puRine\nY pYrimidine\nB not A\nD not C\nH not G\nV not T\nN any\nO omitted\nX masked\n. gap\n- gap\n? gap\nThe code char is treated case-insensitive. If the given code char is not valid, an std::out_of_range exception is thrown."},
    {"bool ::genesis::sequence::validate_chars (SequenceSet const & set, std::string const & chars)", "Returns true iff all sequences only consist of the given chars.\n\nFor presettings of usable chars, see the functions nucleic_acid_codes_... and amino_acid_codes_.... For example, to check whether the sequences are nucleic acids, use nucleic_acid_codes_all(). The chars are treated case-insensitive.If chars contains invalid (non-standard ASCII) characters, an std::invalid_argument exception is thrown."},
    {"bool ::genesis::tree::validate (TreeType const & tree)", "Validate that all pointers of the tree elements (links, nodes, edges) to each other are correct and that some other invariants are met.\n\nThis check is a bit pedantic, but better safe than sorry."},
    {"std::string ::genesis::sequence::amino_acid_codes_all ()", "Return all valid amino acid codes. Those are \"ACDEFGHIKLMNOPQRSTUVWYBJZX*-?\"."},
    {"std::string ::genesis::sequence::amino_acid_codes_degenerated ()", "Return all degenerated amino acid codes. Those are \"BJZ\"."},
    {"std::string ::genesis::sequence::amino_acid_codes_plain ()", "Return all plain amino acid codes. Those are \"ACDEFGHIKLMNOPQRSTUVWY\"."},
    {"std::string ::genesis::sequence::amino_acid_codes_undetermined ()", "Return all undetermined amino acid codes. Those are \"X*-?\"."},
    {"std::map< char, std::string > ::genesis::sequence::amino_acid_text_colors ()", "Return a map of colors for each amino acid code.\n\nThis function gives a color name usable for utils::Style for each amino acid code. The return value of this function can for example be used in sequence::print_color() function."},
    {"std::map< char, double > ::genesis::sequence::base_frequencies (Sequence const & seq, std::string const & plain_chars)", "Get the base frequencies of the sites in a Sequence given the base chars.\n\nThis returns the relative proportions of the given plain_chars to each other. Typically, the given chars come from either nucleic_acid_codes_plain() or amino_acid_codes_plain(), depending on the dataset.It is necessary to select those chars on a per-dataset basis, as it is up to the user to define the meaning of those chars."},
    {"std::map< char, double > ::genesis::sequence::base_frequencies (SequenceSet const & set, std::string const & plain_chars)", "Get the base frequencies of the sites in a SequenceSet given the base chars.\n\nSee the Sequence implementation of this function for details."},
    {"std::map< char, double > ::genesis::sequence::base_frequencies_accumulator (std::map< char, size_t > const & sitehistogram, std::string const & plain_chars)", "Local helper function that turns a site histogram into base frequencies."},
    {"size_t ::genesis::sequence::count_chars (SequenceSet const & set, std::string const & chars)", "Count the number of occurrences of the given chars within the sites of the SequenceSet.\n\nThis function can be used to count e.g. gaps or ambiguous characters in sequences. For presettings of usable chars, see the functions nucleic_acid_codes_... and amino_acid_codes_.... The chars are treated case-insensitive.If chars contains invalid (non-standard ASCII) characters, an std::invalid_argument exception is thrown."},
    {"Sequence const * ::genesis::sequence::find_sequence (SequenceSet const & set, std::string const & label)", "Return a pointer to a sequence with a specific label, or nullptr iff not found."},
    {"double ::genesis::sequence::gapyness (SequenceSet const & set, std::string const & undetermined_chars)", "Return the \"gapyness\" of the sequences, i.e., the proportion of gap chars and other completely undetermined chars to the total length of all sequences.\n\nThis function returns a value in the interval 0.0 (no gaps and undetermined chars at all) and 1.0 (all chars are undetermined). See nucleic_acid_codes_undetermined() and amino_acid_codes_undetermined() for presettings of gap character that can be used here depending on the data set type. The chars are treated case-insensitive. In the special case that there are no sequences or sites, 0.0 is returned."},
    {"bool ::genesis::sequence::is_alignment (SequenceSet const & set)", "Return true iff all sequences in the set have the same length."},
    {"std::array< bool, 128 > ::genesis::sequence::make_lookup_table (std::string const & chars)", "Local helper function to create a case-insensitive lookup table."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_all ()", "Return all valid nucleic acid codes. Those are \"ACGTUWSMKRYBDHVNOX.-?\"."},
    {"std::map< char, std::string > ::genesis::sequence::nucleic_acid_text_colors ()", "Return a map of colors for each nucleic acid code.\n\nThis function gives a color name usable for utils::Style for each nucleic acid code. The return value of this function can for example be used in sequence::print_color() function."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_degenerated ()", "Return all degenerated nucleic acid codes. Those are \"WSMKRYBDHV\"."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_plain ()", "Return all plain nucleic acid codes. Those are \"ACGTU\"."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_undetermined ()", "Return all undetermined nucleic acid codes. Those are \"NOX.-?\"."},
    {"void ::genesis::placement::variance_thread (const int offset, const int incr, const std::vector< PqueryPlain > * pqrys, const utils::Matrix< double > * node_distances, double * partial, bool with_pendant_length)", "Internal function that calculates the sum of distances for the variance that is contributed by a subset of the pqueries. See variance() for more information.\n\nThis function is intended to be called by variance()  it is not a stand-alone function. It takes an offset and an incrementation value and does an interleaved loop over the pqueries, similar to the sequential version for calculating the variance."},
    {"void ::genesis::placement::sort_placements_by_like_weight_ratio (Sample & smp)", "Sort the PqueryPlacements of all Pqueries  by their like_weight_ratio, in descending order (most likely first)."},
    {"size_t ::genesis::placement::total_placement_count (Sample const & smp)", "Get the total number of PqueryPlacements in all Pqueries  of the given Sample."},
    {"double ::genesis::placement::total_placement_mass (Sample const & smp)", "Get the summed mass of all PqueryPlacements in all Pqueries  of the given Sample, where mass is measured by like_weight_ratio."},
    {"tree::TreeSet< PlacementTree > ::genesis::placement::tree_set (SampleSet const & sset)", "Return a TreeSet containing all the trees of the SampleSet."},
    {"double ::genesis::placement::variance (const Sample & map, bool with_pendant_length)", "Calculate the variance of the placements on a tree.\n\nThe variance is a measure of how far a set of items is spread out in its space (http://en.wikipedia.org/wiki/variance). In many cases, it can be measured using the mean of the items. However, when considering placements on a tree, this does not truly measure how far they are from each other. Thus, this algorithm applies a different method of calculating the variance in terms of squared deviations of all items from each other: $ Var(X) = \\frac{1}{n^2} \\sum_{i=1}^n \\sum_{j=1}^n \\frac{1}{2}(x_i - x_j)^2 $, where $ (x_i - x_j) $ denotes the distance between two placements.According to the formula above, each pair of placements is evaluated twice, and subsequently their distance need to be halfed when being added to the sum of distanaces. Instead of that, we calculate the distance for each pair only once, thus are able skip half the calculations, and of course skip the division by two.Furthermore, the normalizing factor $ \\frac{1}{n^2} $ of the variance usually contains the number of elements being processed. However, as the placements are weighted by their like_weight_ratio, we instead calculate n as the sum of the like_weight_ratio of all placements. In case that for each pquery the ratios of all its placements sum up to 1.0, this number will be equal to the number of pqueries (and thus be equal to the usual case of using the number of elements). However, as this is not required (placements with small ratio can be dropped, so that their sum per pquery is less than 1.0), we cannout simply use the count."},
    {"bool ::genesis::placement::validate (Sample const & smp, bool check_values, bool break_on_values)", "Validate the integrity of the pointers, references and data in a Sample object.\n\nReturns true iff everything is set up correctly. In case of inconsistencies, the function stops and returns false on the first encountered error.If check_values is set to true, also a check on the validity of numerical values is done, for example that the proximal_length is smaller than the corresponding branch_length. If additionally break_on_values is set, validate() will stop on the first encountered invalid value. Otherwise it will report all invalid values to the log stream."},
    {"double ::genesis::placement::variance_partial (const PqueryPlain & pqry_a, const std::vector< PqueryPlain > & pqrys_b, const utils::Matrix< double > & node_distances, bool with_pendant_length)", "Internal function that calculates the sum of distances contributed by one pquery for the variance. See variance() for more information.\n\nThis function is intended to be called by variance() or variance_thread()  it is not a stand-alone function."},
    {"std::vector< int > ::genesis::placement::closest_leaf_distance_histogram_auto (Sample const & smp, double & min, double & max, const int bins)", "Returns the same type of histogram as closest_leaf_distance_histogram(), but automatically determines the needed boundaries.\n\nSee closest_leaf_distance_histogram() for general information about what this function does. The difference between both functions is that this one first procresses all distances from placements to their closest leaf nodes to find out what the shortest and longest are, then sets the boundaries of the histogram accordingly. The number of bins is then used to divide this range into intervals of equal size.The boundaries are returned by passing two doubles min and max to the function by reference. The value of max will actually contain the result of std::nextafter() called on the longest distance; this makes sure that the value itself will be placed in the interval.Example: double min, max;\nint    bins = 25;\nstd::vector<int> hist = closest_leaf_distance_histogram (min, max, bins);\ndouble bin_size = (max - min) / bins;\nLOG_INFO << \"Histogram boundaries: [\" << min << \",\" << max << \").\";\nfor (unsigned int bin = 0; bin < hist.size(); ++bin) {\n    LOG_INFO << \"Bin \" << bin << \" [\" << bin * bin_size << \"; \" << (bin+1) * bin_size << \") has \" << hist[bin] << \" placements.\";\n}\nIt has a slightly higher time and memory consumption than the non-automatic version closest_leaf_distance_histogram(), as it needs to process the values twice in order to find their min and max."},
    {"void ::genesis::placement::copy_pqueries (Sample const & source, Sample & target)", "Copy all Pqueries  from the source Sample (left parameter) to the target Sample (right parameter).\n\nFor this method to succeed, the PlacementTrees of the Samples need to have the same topology, including identical edge_nums and node names. Otherwise, this function throws an std::runtime_error.The PlacementTree of the target Sample is not modified. If the average branch length tree is needed instead, see SampleSet::merge_all()."},
    {"void ::genesis::placement::collect_duplicate_pqueries (Sample & smp)", "Find all Pqueries  that share a common name and combine them into a single Pquery containing all their collective PqueryPlacements and PqueryNames.\n\nThe function collects all Pqueries that share at least one name. This is transitive, so that for example three Pqueries with two names each like (a,b) (b,c) (c,d) will be combined into one Pquery. Thus, the transitive closure of shared names is collected.All those Pqueries with shared names are combined by simply moving all their Placements and Names into one Pquery and deleting the others. This means that at least the shared names will be doubled after this function. Also, Placements on the same edge can occur. Thus, usually merge_duplicate_names() and merge_duplicate_placements() are called after this function. The function merge_duplicates() does exaclty this, for convenience."},
    {"Sample ::genesis::placement::merge_all (SampleSet const & sset)", "Returns a Sample where all maps of this set have been merged into.\n\nFor this method to succeed, all Samples need to have the same topology, including identical edge_nums and node names. The Tree of the returned Sample has the average branch lenghts from the input trees, using TreeSet::average_branch_length_tree()."},
    {"void ::genesis::placement::merge_duplicates (Sample & smp)", "Look for Pqueries  with the same name and merge them.\n\nThis function is a wrapper that simply calls three other functions on the provided Sample: * collect_duplicate_pqueries()\n* merge_duplicate_names()\n* merge_duplicate_placements()\nSee there for more information on what they do."},
    {"void ::genesis::placement::merge_duplicate_names (Pquery & pquery)", "Merge all PqueryNames that have the same name property into one, while adding up their multiplicity."},
    {"void ::genesis::placement::merge_duplicate_names (Sample & smp)", "Call merge_duplicate_names() for each Pquery of the Sample."},
    {"void ::genesis::placement::merge_duplicate_placements (Pquery & pquery)", "Merge all PqueryPlacements of a Pquery that are on the same TreeEdge into one averaged PqueryPlacement.\n\nThe merging is done via averaging all values of the PqueryPlacement: likelihood, like_weight_ratio, proximal_length, pendant_length and parsimony."},
    {"void ::genesis::placement::merge_duplicate_placements (Sample & smp)", "Call merge_duplicate_placements( Pquery& ) for each Pquery of a Sample."},
    {"TreeSetType::TreeType * ::genesis::placement::find_tree (TreeSetType & tset, std::string const & name)", "Get the first Tree in a TreeSet that is stored with a given name, or nullptr if not found."},
    {"Sample * ::genesis::placement::find_sample (SampleSet & sset, std::string const & name)", "Get the first Sample in a SampleSet that has a given name, or nullptr if not found."},
    {"TreeSetType::TreeType const * ::genesis::placement::find_tree (TreeSetType const & tset, std::string const & name)", "Get the first Tree in a TreeSet that is stored with a given name, or nullptr if not found."},
    {"Sample const * ::genesis::placement::find_sample (SampleSet const & sset, std::string const & name)", "Get the first Sample in a SampleSet that has a given name, or nullptr if not found."},
    {"bool ::genesis::placement::has_correct_edge_nums (PlacementTree const & tree)", "Verify that the tree has correctly set edge nums.\n\nThe edge_num property of the PlacementTreeEdges is defined by the jplace standard. The values have to be assigned increasingly with a postorder traversal of the tree. This function checks whether this is the case."},
    {"bool ::genesis::placement::has_name (Sample const & smp, std::string const & name)", "Return true iff the given Sample contains a Pquery with a particular name, i.e., a PqueryName whose name member equals the given name."},
    {"bool ::genesis::placement::has_name (Pquery const & pquery, std::string const & name)", "Return true iff the given Pquery contains a particular name."},
    {"Pquery const * ::genesis::placement::find_pquery (Sample const & smp, std::string const & name)", "Return the first Pquery that has a particular name, or nullptr of none has."},
    {"double ::genesis::placement::earth_movers_distance (const Sample & lhs, const Sample & rhs, bool with_pendant_length)", "Calculates the Earth Movers Distance between two sets of placements on a fixed reference tree."},
    {"std::unordered_map< int, PlacementTree::EdgeType * > ::genesis::placement::edge_num_to_edge_map (PlacementTree const & tree)", "Return a mapping of edge_num integers to the corresponding TreeEdge object.\n\nThis function depends on the tree only and does not involve any pqueries."},
    {"std::unordered_map< int, PlacementTree::EdgeType * > ::genesis::placement::edge_num_to_edge_map (Sample const & smp)", "Return a mapping of edge_num integers to the corresponding TreeEdge object.\n\nThis function depends on the tree only and does not involve any pqueries."},
    {"std::vector< utils::Color > ::genesis::placement::placement_color_count_gradient (Sample const & smp, bool linear)", "Returns a vector with a Color for each edge that visualizes the number of placements on that edge.\n\nThe vector is indexed using the edge.index(). Each edge gets assigned a Color value with these properties:\nEdges with no placements on them are grey (RGB 128, 128, 128).Edges with placements get a color according to the relative number of placements compared to the other edges. The edge with most placements is pure red (RGB 255, 0, 0), while lower numbers of placements smoothly transition towards yellow and green edges.\nThe gradient can be controlled via the linear parameter. If set to true, the scaling of the color gradient is linar in the number of placements. If set to false (default), it is logarithmic. This way, the color resolution is higher for low placement numbers, and compressed for higher numbers. A typical distribution of placements yields only some edges with a very high number of placements, while most of the other edges have little to no placements. Thus, it is reasonable to emphasize the differences between those edges with a lower placement count - which is what the default does.See color heat_gradient() for more information."},
    {"double ::genesis::placement::pairwise_distance (const Sample & map_a, const Sample & map_b, bool with_pendant_length)", "Calculate the normalized pairwise distance between all placements of the two Samples.\n\nThis method calculates the distance between two maps as the normalized sum of the distances between all pairs of pqueries in the map. It is similar to the variance() calculation, which calculates this sum for the squared distances between all pqueries of one map.\n\nmap_a\n\n\nThe first Sample to which the distances shall be calculated to. \n\n\n\nmap_b\n\n\nThe second Sample to which the distances shall be calculated to. \n\n\n\nwith_pendant_length\n\n\nWhether or not to include all pendant lengths in the calculation.\n\n\nDistance value."},
    {"std::pair< PlacementTreeEdge const *, size_t > ::genesis::placement::placement_count_max_edge (Sample const & smp)", "Get the number of placements on the edge with the most placements, and a pointer to this edge."},
    {"std::vector< int > ::genesis::placement::closest_leaf_depth_histogram (Sample const & smp)", "Return a histogram representing how many placements have which depth with respect to their closest leaf node.\n\nThe depth between two nodes on a tree is the number of edges between them. Thus, the depth of a placement (which sits on an edge of the tree) to a specific node is the number of edges between this node and the closer one of the two nodes at the end of the edge where the placement sits.The closest leaf to a placement is thus the leaf node which has the smallest depth to that placement. This function then returns a histogram of how many placements (values of the vector) are there that have a specific depth (indices of the vector) to their closest leaf.Example: A return vector of histogram[0] = 2334\nhistogram[1] = 349\nhistogram[2] = 65\nhistogram[3] = 17\nmeans that there are 2334 placements that sit on an edge which leads to a leaf node (thus, the depth of one of the nodes of the edge is 0). It has 349 placements that sit on an edge where one of its nodes has one neighbour that is a leaf; and so on.The vector is automatically resized to the needed number of elements."},
    {"void ::genesis::placement::normalize_weight_ratios (Sample & smp)", "Recalculate the like_weight_ratio of the PqueryPlacement&s of each Pquery in the Sample, so that their sum is 1.0, while maintaining their ratio to each other."},
    {"std::ostream & ::genesis::placement::operator<< (std::ostream & out, Sample const & smp)", "Print a table of all Pqueries with their Placements and Names to the stream."},
    {"std::vector< int > ::genesis::placement::closest_leaf_distance_histogram (Sample const & smp, const double min, const double max, const int bins)", "Returns a histogram counting the number of placements that have a certain distance to their closest leaf node, divided into equally large intervals between a min and a max distance.\n\nThe distance range between min and max is divided into bins many intervals of equal size. Then, the distance from each placement to its closest leaf node is calculated and the counter for this particular distance inverval in the histogram is incremented.The distance is measured along the branch_length values of the edges, taking the pendant_length and proximal_length of the placements into account. If the distances is outside of the interval [min,max], the counter of the first/last bin is incremented respectively.Example: double min      =  0.0;\ndouble max      = 20.0;\nint    bins     = 25;\ndouble bin_size = (max - min) / bins;\nstd::vector<int> hist = closest_leaf_distance_histogram (min, max, bins);\nfor (unsigned int bin = 0; bin < hist.size(); ++bin) {\n    LOG_INFO << \"Bin \" << bin << \" [\" << bin * bin_size << \"; \" << (bin+1) * bin_size << \") has \" << hist[bin] << \" placements.\";\n}"},
    {"std::pair< PlacementTreeEdge const *, double > ::genesis::placement::center_of_gravity (const Sample & map, bool with_pendant_length)", "Calculate the Center of Gravity of the placements on a tree.\n\nThe center of gravity is the point on the tree where all masses of the placements on the one side of it times their distance from the point are equal to this sum on the other side of the point. In the following example, the hat ^ marks this point on a line with two placements: One has mass 1 and distance 3 from the central point, and one as mass 3 and distance 1, so that the product of their mass and distance to the point is the same:               3\n              |\n1             |\n|_____________|\n          ^\nIt is thus like calculating masses and torques on a lever in order to find their physical center of mass/gravity.This calculation is done for the whole tree, with the masses calculated from the like_weight_ratio and distances in terms of the branch_length of the edges and the proximal_length and (if specificed in the method parameter) the pendant_length of the placements."},
    {"bool ::genesis::contains (const C & v, const T & x)", "Returns whether a container object has a certain element.\n\nThe usage of std::find just to check for presence of a certain item is a bit cumbersome. This template simply takes any container and a value and returns true iff the value is present in the container."},
    {"double ::genesis::placement::center_of_gravity_variance (const Sample & map, bool with_pendant_length)", "$ Var(X) = E[ (x - \\mu)^2 ] = \\frac{\\sum (x - \\mu)^2 \\cdot \\omega} {\\sum \\omega} $, where the weights $ \\omega $ are the like_weight_ratios of the placements."},
    {"std::pair< PlacementTreeEdge const *, double > ::genesis::placement::placement_mass_max_edge (Sample const & smp)", "Get the summed mass of the placements on the heaviest edge, measured by their like_weight_ratio, and a pointer to this edge."},
    {"std::unique_ptr< T > ::genesis::make_unique (Args &&... args)", "Returns a std::unique_ptr for a given type.\n\nSince this is not available in C++11, we need our own implementation. It is following http://herbsutter.com/gotw/_102/"},
    {"void ::genesis::erase_if (Container & c, UnaryPredicate p)", "Erases all elements from the container that satisfy a given predicate. An element is erased, if the predicate evaluates to true for it. The predicate needs to have a signature similar to (T const&)->bool.\n\nc\n\n\nThe container to modify. \n\n\n\np\n\n\nThe predicate to satisfy."},
    {"std::string ::genesis::genesis_version ()", "Return the current genesis version.\n\nWe use semantic versioning 2.0.0 for genesis."},
    {"std::string ::genesis::genesis_header ()", "Return the header for genesis."},
    {"std::unordered_map< size_t, std::vector< PqueryPlacement const * > > ::genesis::placement::placements_per_edge (Sample const & smp)", "Return a mapping from PlacementTreeEdge indices to a vector of all PqueryPlacements that are placed on that edge, for all edges of the Sample.\n\nThis map is invalidated after calling Pquery::add_placement()."},
    {"std::vector< PqueryPlain > ::genesis::placement::plain_queries (Sample const & smp)", "Return a plain representation of all pqueries of this map.\n\nThis method produces a whole copy of all pqueries and their placements (though, not their names) in a plain POD format. This format is meant for speeding up computations that need access to the data a lot - which would require several pointer indirections in the normal representation of the data.This comes of course at the cost of reduced flexibility, as all indices are fixed in the plain data structre: changing a value here will not have any effect on the original data or even on the values of the pqueries. Thus, most probably this will lead to corruption. Therefore, this data structure is meant for reading only."},
    {"std::vector< PqueryPlacement const * > ::genesis::placement::placements_per_edge (Sample const & smp, PlacementTreeEdge const & edge)", "Return a vector of all PqueryPlacements that are placed on the given PlacementTreeEdge.\n\nThis functions iterates over all placements and collects those that are placed on the given edge. In case that this is needed for multiple edges, it will be faster to use placements_per_edge( Sample ) instead.This map is invalidated after calling Pquery::add_placement()."},
    {"double ::genesis::placement::pquery_distance (const PqueryPlain & pqry_a, const PqueryPlain & pqry_b, const utils::Matrix< double > & node_distances, bool with_pendant_length)", "Calculates the normalized distance between two plain pqueries. It is mainly a helper method for distance calculations (e.g., pairwise distance, variance).\n\nFor each placement in the two pqueries, a distance is calculated, and their normalized sum is returned. Normalization is done using the mass of placements in both pqueries.The distance between two placements is calculated as the shortest path between them. This includes the their position on the branches, and - if specified - the pendant_length of both. There are three cases that might occur:\nBoth placements are on the same branch. In this case, their distance is caluclated as their difference in proximal_lengths (plus if specified the sum of their pendant_lengths).The path between the placements includes the root. The distance of a placement from its neighbouring nodes is usually given in form of the proximal_length, which is the distance of the placement to the node (at the end of its branch) that lies in direction of the root. Thus, there is an implicit notion of a root, that we need to consider. If the path between two placements contains the root, we can directly calculate their distance as the distance between the two promixal nodes plus proximal_lengths (and possibly pendant_lengths) of both placements. We call this the promixal-promixal case.The root is not part of the path between the placements. This case means that one of the two placements lies on the path between the other placement and the root  thus, the path between the placements does not contain the root. The distance between the placements cannot be calculated using the proximal_lengths directly, but we need to get the distal_length (away from the root) of the inner placement first. This is simply the difference between branch_length and proximal_length of that placement. Of course, this case comes in two flavours, because both placements can be the inner or outer one. They are called proximal-distal case and distal-proximal case, respectively.\nThe first case is easy to detect by comparing the edge nums. However, distinguishing between the latter two cases is expensive, as it involves finding the path to the root for both placements. To speed this up, we instead use a distance matrix that is calculated in the beginning of any algorithm using this method and contains the pairwise distances between all nodes of the tree. Using this, we do not need to find paths between placements, but simply go to the nodes at the end of the branches of the placements and do a lookup for those nodes.With this technique, we can calculate the distances between the placements for all three cases (promixal-promixal, proximal-distal and distal-proximal) cheaply. The wanted distance is then simply the minimum of those three distances. This is correct, because the two wrong cases will always produce an overestimation of the distance.This distance is normalized using the like_weight_ratio of both placements, before summing it up to calculate the total distance between the pqueries."},
    {"void ::genesis::placement::restrain_to_max_weight_placements (Pquery & pquery)", "Remove all PqueryPlacements but the most likely one from the Pquery.\n\nPqueries can contain multiple placements on different branches. For example, the EPA algorithm of RAxML outputs up to the 7 most likely positions for placements to the output Jplace file by default. The property like_weight_ratio weights those placement positions so that the sum over all positions (all branches of the tree) per pquery is 1.0.This function removes all but the most likely placement (the one which has the maximal like_weight_ratio) from the Pquery. It additionally sets the like_weight_ratio of the remaining placement to 1.0, as this one now is the only one left, thus its \"sum\" has to be 1.0."},
    {"std::string ::genesis::placement::print_tree (Sample const & smp)", "Return a simple view of the Tree of a Sample with information about the Pqueries  on it."},
    {"void ::genesis::placement::restrain_to_max_weight_placements (Sample & smp)", "Remove all PqueryPlacements but the most likely one from all Pqueries  in the Sample.\n\nThis function calls restrain_to_max_weight_placements( Pquery& pquery ) for all Pqueries of the Sample. See this version of the function for more information."},
    {"void ::genesis::placement::sort_placements_by_like_weight_ratio (Pquery & pquery)", "Sort the PqueryPlacements of a Pquery by their like_weight_ratio, in descending order (most likely first)."},
    {"bool ::genesis::placement::all_equal (TreeSetType const & tset, std::function< bool(typename TreeSetType::TreeType::NodeType const &, typename TreeSetType::TreeType::NodeType const &)> node_comparator, std::function< bool(typename TreeSetType::TreeType::EdgeType const &, typename TreeSetType::TreeType::EdgeType const &)> edge_comparator)", "Compare whether all Trees in a TreeSet are equal using a given comparator functional.\n\nSee Tree::equal() for more information."},
    {"bool ::genesis::placement::all_equal (TreeSetType const & tset)", "Compare whether all Trees in a TreeSet are equal using their default comparision operators for nodes and edges."},
    {"TreeSetType::TreeType ::genesis::placement::average_branch_length_tree (TreeSetType const & tset)", "Return a Tree where the branch lengths are the average of the Trees in the TreeSet, given that they all have the same topology.\n\nThe function works only under the following conditions: * All trees must have the same topology.\n* The TreeType must provide a data member `branch_length` for the edges.\nOtherwise, the function throws an std::runtime_error. It does not check for node names, but the returned tree will contain the names of the first tree in the set.TODO this function assumes that the tree edge has a branch_length. move it to default tree."},
    {"bool ::genesis::placement::all_identical_topology (TreeSetType const & tset)", "Return true iff all Trees in a TreeSet have an identical topology."},
    {"bool ::genesis::placement::all_identical_trees (SampleSet const & sset)", "Returns true iff all Trees of the Samples in the set are identical.\n\nThis is the case if they have the same topology, node names and edge_nums. However, branch lengths are not checked, because usually those differ slightly."},
};

const char* get_docstring (const std::string& signature)
{
    if (doc_strings_.count(signature) > 0) {
        return doc_strings_[signature].c_str();
    } else {
        return "";
    }
}
